(function() {
    'use strict';
 
    // =================================================================================================
    // CONFIGURATION
    // =================================================================================================
    const config = {
        detection: {
            enabled: true, // Toggle AI detection on/off
            modelType: poseDetection.SupportedModels.MoveNet, // AI model to use (MoveNet is fastest)
            detectorConfig: {
                modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING, // Lightning model for speed
                enableSmoothing: true, // Smooths detection between frames
                minPoseScore: 0.25 // Minimum confidence score to consider a detection valid
            },
            keypointConfidence: 0.20, // Minimum confidence for individual body keypoints
            maxDetections: 1, // Maximum number of players to detect
            processingInterval: 5, // Process every Nth frame (higher = better performance)
            skipFrames: 1, // Additional frames to skip between processing
            ignoreSelfRegion: { // Area to ignore (your character)
                enabled: true, // Toggle self-region ignore
                xPercent: 0.00, // X position (0-1 = left-right)
                yPercent: 0.27, // Y position (0-1 = top-bottom)
                widthPercent: 0.37, // Width of ignored region
                heightPercent: 0.74 // Height of ignored region
            }
        },
        game: {
            videoSelector: 'video[aria-label="Game Stream for unknown title"]', // CSS selector for game video
            containerSelector: '#game-stream', // CSS selector for game container
            autoShoot: false, // Enable automatic shooting when target locked
            triggerOptions: {
                delayBeforeShoot: 10, // Milliseconds delay before shooting
                burstMode: false, // Enable burst fire mode
                burstCount: 3, // Number of shots in burst
                burstInterval: 100 // Milliseconds between burst shots
            }
        },
        aim: {
            activationKey: 'KeyQ', // Hotkey to activate aimbot (KeyQ = Q key)
            fovRadius: 150, // Radius in pixels for target acquisition
            aimPoint: "torso_center", // Where to aim on body (torso_center/head/etc)
            headOffset: 0.15, // Vertical offset when aiming for head
            bodyOffset: 0.4, // Vertical offset when aiming for body
            targetPriority: "center", // Priority targets near screen center or mouse
            targetSwitchCooldown: 0.1, // Seconds before switching to new target
            triggerThreshold: 0.7, // How close to center before shooting (0-1)
            aimSpeed: { // Smooth aiming settings
                enabled: true, // Toggle smooth aiming
                speedPercent: 45.0 // Speed percentage (lower = smoother)
            },
            prediction: { // Advanced target prediction
                enabled: false, // Toggle prediction system
                latencyCompensation: 50, // Milliseconds to compensate for delay
                jitterBufferSize: 3, // Frames to analyze for smoothing
                maxVelocity: 1000, // Maximum predicted speed (pixels/sec)
                smoothingFactor: 0.2, // How much to smooth movements (0-1)
                predictionScale: 1.2 // How far to predict ahead
            }
        },
        visual: {
            showDebugInfo: true, // Show technical info overlay
            rainbowMode: { // Fun colorful mode
                enabled: true, // Toggle rainbow colors
                speed: 0.1 // Rainbow color cycle speed
            },
            crosshair: { // Crosshair settings
                enabled: true, // Toggle crosshair
                style: 'dot', // Type: dot/cross/circle
                color: 'lime', // Default color
                size: 3, // Size in pixels
                centerOnGameScreen: true // Lock to game center
            },
            targetLock: { // Target highlighting
                enabled: true, // Toggle target box
                color: 'red', // Box color
                style: 'full' // Style: full/corners
            },
            fovCircle: { // Field of view indicator
                enabled: true, // Toggle FOV circle
                color: 'rgba(255,255,255,0.3)', // Circle color
                lineWidth: 1, // Border thickness
                centerOnGameScreen: true, // Lock to game center
                showOnlyWhenAiming: true // Only show when active
            },
            performanceMetrics: { // FPS counter
                enabled: true, // Toggle performance display
                position: 'top-left' // Screen position
            },
            drawIgnoreRegion: { // Visualize ignored area
                enabled: true, // Toggle region display
                color: 'rgba(50, 50, 50, 0.4)', // Shading color
                lineWidth: 1, // Border thickness
                showOnlyWhenAiming: true // Only show when active
            }
        }
    };
 
    // =================================================================================================
    // STATE
    // =================================================================================================
    const state = {
        gameVideo: null,
        detectionModel: null,
        modelLoaded: false,
        currentTarget: null,
        lastTargetSwitch: 0,
        frameCount: 0,
        lastDetectionTime: 0,
        rainbowHue: 0,
        performance: {
            fps: 0,
            framesThisSecond: 0,
            lastFpsUpdate: 0,
            detectionTime: 0,
            avgDetectionTime: 0,
            detectionTimeHistory: []
        },
        ui: {
            overlayCanvas: null,
            overlayCtx: null,
            offscreenCanvas: null,
            offscreenCtx: null
        },
        input: {
            lastMouseX: window.innerWidth / 2,
            lastMouseY: window.innerHeight / 2,
            leftButtonDown: false,
            rightButtonDown: false,
            shootingStartTime: 0,
            activeKeys: new Set()
        },
        isShooting: false,
        currentWeapon: 0,
        prediction: {
            networkLatency: 0,
            lastTargetId: null,
            targetHistory: {}, // Stores history for each target
            lastPrediction: { x: 0, y: 0 },
            backend: 'unknown'
        }
    };
 
    // =================================================================================================
    // DEBUGGER
    // =================================================================================================
    const debug = {
        log: (...args) => console.log(`[Capybara AI Aimbot]`, ...args),
        warn: (...args) => console.warn(`[Capybara AI Aimbot]`, ...args),
        error: (...args) => console.error(`[Capybara AI Aimbot]`, ...args)
    };
 
    function showNotification(message, type = 'info', duration = 3000) {
        const n = document.createElement('div');
        n.style.cssText = `position:fixed;top:20px;left:50%;transform:translateX(-50%);padding:10px 20px;border-radius:5px;color:white;z-index:1000000;font-family:sans-serif;font-size:16px;box-shadow:0 2px 10px rgba(0,0,0,0.2);background-color:${
            type === 'error' ? 'rgba(255,0,0,0.8)' : 
            type === 'warning' ? 'rgba(255,165,0,0.8)' : 
            'rgba(0,0,0,0.7)'}`;
        n.textContent = message;
        document.body.appendChild(n);
        setTimeout(() => n.remove(), duration);
    }
 
    // =================================================================================================
    // IMPROVED PREDICTION SYSTEM
    // =================================================================================================
    function initializeTargetHistory(targetId) {
        if (!state.prediction.targetHistory[targetId]) {
            state.prediction.targetHistory[targetId] = {
                positions: [],
                timestamps: [],
                velocities: [],
                smoothedVelocity: { x: 0, y: 0 }
            };
        }
    }
 
    function updateTargetHistory(targetId, position, timestamp) {
        initializeTargetHistory(targetId);
        const history = state.prediction.targetHistory[targetId];
 
        // Add current position and timestamp
        history.positions.push({ x: position.x, y: position.y });
        history.timestamps.push(timestamp);
 
        // Calculate velocity if we have previous data
        if (history.positions.length > 1) {
            const prevPos = history.positions[history.positions.length - 2];
            const prevTime = history.timestamps[history.timestamps.length - 2];
            const dt = (timestamp - prevTime) / 1000; // seconds
 
            if (dt > 0) {
                const vx = (position.x - prevPos.x) / dt;
                const vy = (position.y - prevPos.y) / dt;
 
                // Limit velocity to prevent extreme predictions
                const maxV = config.aim.prediction.maxVelocity;
                const limitedVx = Math.max(-maxV, Math.min(maxV, vx));
                const limitedVy = Math.max(-maxV, Math.min(maxV, vy));
 
                history.velocities.push({ x: limitedVx, y: limitedVy });
 
                // Smooth the velocity using exponential smoothing
                const smoothing = config.aim.prediction.smoothingFactor;
                history.smoothedVelocity.x = history.smoothedVelocity.x * (1 - smoothing) + limitedVx * smoothing;
                history.smoothedVelocity.y = history.smoothedVelocity.y * (1 - smoothing) + limitedVy * smoothing;
            }
        }
 
        // Maintain jitter buffer size
        const bufferSize = config.aim.prediction.jitterBufferSize;
        if (history.positions.length > bufferSize) {
            history.positions.shift();
            history.timestamps.shift();
            if (history.velocities.length > 0) history.velocities.shift();
        }
    }
 
    function calculatePredictedPosition(targetId) {
        if (!state.prediction.targetHistory[targetId] || 
            state.prediction.targetHistory[targetId].positions.length < 2) {
            return null;
        }
 
        const history = state.prediction.targetHistory[targetId];
        const currentPos = history.positions[history.positions.length - 1];
        const currentTime = history.timestamps[history.timestamps.length - 1];
 
        // Calculate total latency to compensate for (network + processing)
        const totalLatency = state.prediction.networkLatency + 
                           state.performance.detectionTime + 
                           config.aim.prediction.latencyCompensation;
 
        // Use smoothed velocity for prediction
        const vx = history.smoothedVelocity.x;
        const vy = history.smoothedVelocity.y;
 
        // Apply prediction scale factor
        const scale = config.aim.prediction.predictionScale;
 
        // Calculate predicted position
        const predictedX = currentPos.x + (vx * totalLatency / 1000) * scale;
        const predictedY = currentPos.y + (vy * totalLatency / 1000) * scale;
 
        return {
            x: predictedX,
            y: predictedY,
            velocityX: vx,
            velocityY: vy
        };
    }
 
    function updateTargetPrediction(newTarget) {
        const now = performance.now();
 
        if (!newTarget) {
            state.prediction.lastTargetId = null;
            return;
        }
 
        // Initialize or update history for this target
        updateTargetHistory(newTarget.id, newTarget.screenPosition, now);
 
        state.prediction.lastTargetId = newTarget.id;
    }
 
    // =================================================================================================
    // BACKEND INITIALIZATION
    // =================================================================================================
    async function setupTensorFlow() {
        try {
            debug.log("Initializing TensorFlow.js with optimal backend...");
 
            const backends = [
                { name: 'webnn', test: () => typeof navigator.ml !== 'undefined' },
                { name: 'webgpu', test: () => typeof navigator.gpu !== 'undefined' },
                { name: 'webgl', test: () => true }
            ];
 
            let selectedBackend = null;
 
            for (const backend of backends) {
                if (backend.test()) {
                    try {
                        await tf.setBackend(backend.name);
                        await tf.ready();
 
                        if (backend.name === 'webgl') {
                            tf.env().set('WEBGL_VERSION', 2);
                            tf.env().set('WEBGL_CPU_FORWARD', false);
                            tf.env().set('WEBGL_PACK', true);
                            tf.env().set('WEBGL_FORCE_F16_TEXTURES', true);
                            tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);
                            tf.env().set('WEBGL_FLUSH_THRESHOLD', 1.75);
                        }
 
                        selectedBackend = backend.name;
                        state.prediction.backend = backend.name;
                        debug.log(`Successfully initialized ${backend.name.toUpperCase()} backend`);
                        break;
                    } catch (e) {
                        debug.warn(`Failed to initialize ${backend.name}:`, e.message);
                    }
                }
            }
 
            if (!selectedBackend) {
                throw new Error("Could not initialize any backend");
            }
 
            return true;
        } catch (e) {
            debug.error("TF setup failed:", e);
            showNotification("Failed to initialize AI backend", "error");
            return false;
        }
    }
 
    // =================================================================================================
    // MODEL LOADING
    // =================================================================================================
    async function loadDetectionModel() {
        debug.log("Loading MoveNet model...");
        try {
            if (!await setupTensorFlow()) throw new Error("TF setup failed");
            if (typeof poseDetection === "undefined") throw new Error("Pose Detection API not loaded.");
 
            state.detectionModel = await poseDetection.createDetector(
                config.detection.modelType, 
                config.detection.detectorConfig
            );
 
            const tC = document.createElement('canvas');
            tC.width = 192;
            tC.height = 192;
            await state.detectionModel.estimatePoses(tC);
 
            state.modelLoaded = true;
            debug.log("MoveNet model loaded!");
            showNotification(`AI Model Loaded (${state.prediction.backend.toUpperCase()})`, "info");
            return true;
        } catch (e) {
            debug.error("Failed to load MoveNet model:", e);
            showNotification("Error loading AI model! Check console.", "error");
            return false;
        }
    }
 
    // =================================================================================================
    // TARGET DETECTION
    // =================================================================================================
    function calculateBoundingBoxFromKeypoints(kps) {
        if (!kps || kps.length === 0) return null;
 
        let mX = Infinity, mY = Infinity, mAX = -Infinity, mAY = -Infinity, vK = 0;
        kps.forEach(k => {
            if (k.score && k.score >= config.detection.keypointConfidence) {
                mX = Math.min(mX, k.x);
                mY = Math.min(mY, k.y);
                mAX = Math.max(mAX, k.x);
                mAY = Math.max(mAY, k.y);
                vK++;
            }
        });
 
        if (vK < 5) return null;
 
        const w = mAX - mX, h = mAY - mY, pX = 0.1 * w, pY = 0.1 * h;
        return {
            x: Math.max(0, mX - pX),
            y: Math.max(0, mY - pY),
            width: w + 2 * pX,
            height: h + 2 * pY,
            validKeypoints: vK
        };
    }
 
    function calculateAimTarget(pred, vRect) {
        if (!pred || !vRect || !state.gameVideo) return null;
 
        const [vBx, vBy, vBw, vBh] = pred.bbox || [0, 0, 0, 0];
        const sBx = vRect.left + vBx / state.gameVideo.videoWidth * vRect.width;
        const sBy = vRect.top + vBy / state.gameVideo.videoHeight * vRect.height;
        const sBw = vBw / state.gameVideo.videoWidth * vRect.width;
        const sBh = vBh / state.gameVideo.videoHeight * vRect.height;
 
        let tX = sBx + sBw / 2;
        let tY = sBy + sBh * (config.aim?.bodyOffset || 0.4);
 
        return {
            x: tX,
            y: tY,
            width: sBw,
            height: sBh,
            bboxRaw: pred.bbox
        };
    }
 
    function findBestTarget(predictions) {
        if (!predictions || !Array.isArray(predictions)) return null;
        if (!state.gameVideo) return null;
 
        const videoRect = state.gameVideo.getBoundingClientRect();
        if (!videoRect || videoRect.width === 0) return null;
 
        const gameScreenCenterX = videoRect.left + videoRect.width / 2;
        const gameScreenCenterY = videoRect.top + videoRect.height / 2;
        let bestTarget = null;
        let bestScore = Infinity;
 
        predictions.forEach((prediction, index) => {
            const targetInfo = calculateAimTarget(prediction, videoRect);
            if (!targetInfo) return;
 
            let referenceX, referenceY;
            if (config.aim?.targetPriority === "center") {
                referenceX = gameScreenCenterX;
                referenceY = gameScreenCenterY;
            } else {
                referenceX = state.input.lastMouseX;
                referenceY = state.input.lastMouseY;
            }
 
            const dx = targetInfo.x - referenceX;
            const dy = targetInfo.y - referenceY;
            const distanceToPriorityPoint = Math.sqrt(dx * dx + dy * dy);
 
            if (distanceToPriorityPoint > (config.aim?.fovRadius || 200)) return;
 
            let score = distanceToPriorityPoint * (1.5 - (prediction.score || 0));
 
            if (score < bestScore) {
                bestScore = score;
                bestTarget = {
                    prediction,
                    screenPosition: targetInfo,
                    distance: distanceToPriorityPoint,
                    score: prediction.score,
                    id: index
                };
            }
        });
 
        return bestTarget;
    }
 
    // =================================================================================================
    // INPUT CONTROLLER
    // =================================================================================================
    const InputController = {
        init: function() {
            state.input.lastMouseX = window.innerWidth / 2;
            state.input.lastMouseY = window.innerHeight / 2;
 
            document.addEventListener('mousemove', e => {
                state.input.lastMouseX = e.clientX;
                state.input.lastMouseY = e.clientY;
            });
 
            document.addEventListener('keydown', e => state.input.activeKeys.add(e.code));
            document.addEventListener('keyup', e => state.input.activeKeys.delete(e.code));
 
            document.addEventListener('mousedown', e => {
                if (e.button === 0) {
                    state.input.leftButtonDown = true;
                    state.input.shootingStartTime = performance.now();
                }
                if (e.button === 2) state.input.rightButtonDown = true;
            });
 
            document.addEventListener('mouseup', e => {
                if (e.button === 0) {
                    state.input.leftButtonDown = false;
                    state.input.shootingStartTime = 0;
                }
                if (e.button === 2) state.input.rightButtonDown = false;
            });
 
            debug.log("Input controller initialized");
            return true;
        },
 
        moveMouseTo: function(tSX, tSY) {
            if (!state.gameVideo) return;
 
            const vR = state.gameVideo.getBoundingClientRect();
            if (!vR || vR.width === 0) return;
 
            const gVCX = vR.left + vR.width / 2;
            const gVCY = vR.top + vR.height / 2;
            let mX = tSX - gVCX;
            let mY = tSY - gVCY;
 
            const sC = document.querySelector(config.game?.containerSelector) || state.gameVideo || document.documentElement;
            const evt = new PointerEvent('pointermove', {
                bubbles: true,
                cancelable: true,
                view: window,
                clientX: Math.round(state.input.lastMouseX + mX),
                clientY: Math.round(state.input.lastMouseY + mY),
                movementX: Math.round(mX),
                movementY: Math.round(mY),
                pointerType: 'mouse',
                isPrimary: true
            });
            sC.dispatchEvent(evt);
        },
 
        startShooting: function() {
            if (state.isShooting) return;
 
            const sC = document.querySelector(config.game?.containerSelector) || state.gameVideo || document.documentElement;
            const evt = new PointerEvent('pointerdown', {
                bubbles: true,
                cancelable: true,
                view: window,
                clientX: Math.round(state.input.lastMouseX),
                clientY: Math.round(state.input.lastMouseY),
                button: 0,
                buttons: 1,
                pointerType: 'mouse',
                isPrimary: true
            });
            sC.dispatchEvent(evt);
            state.isShooting = true;
        },
 
        stopShooting: function() {
            if (!state.isShooting) return;
 
            const sC = document.querySelector(config.game?.containerSelector) || state.gameVideo || document.documentElement;
            const evt = new PointerEvent('pointerup', {
                bubbles: true,
                cancelable: true,
                view: window,
                clientX: Math.round(state.input.lastMouseX),
                clientY: Math.round(state.input.lastMouseY),
                button: 0,
                pointerType: 'mouse',
                isPrimary: true
            });
            sC.dispatchEvent(evt);
            state.isShooting = false;
        }
    };
 
    // =================================================================================================
    // VISUAL OVERLAY (with safe property access)
    // =================================================================================================
    function createOverlayCanvas() {
        if (state.ui.overlayCanvas) return;
 
        const c = document.createElement('canvas');
        c.id = 'xcloud-aimbot-overlay';
        c.width = window.innerWidth;
        c.height = window.innerHeight;
        c.style.cssText = 'position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:99999;';
 
        state.ui.overlayCanvas = c;
        state.ui.overlayCtx = c.getContext('2d');
        document.body.appendChild(c);
 
        window.addEventListener('resize', () => {
            c.width = window.innerWidth;
            c.height = window.innerHeight;
        });
    }
 
    function drawCrosshair(vR) {
        if (!state.ui.overlayCtx || !config.visual?.crosshair?.enabled) return;
 
        const ctx = state.ui.overlayCtx;
        let cX, cY;
 
        if (config.visual.crosshair?.centerOnGameScreen && vR && vR.width > 0) {
            cX = vR.left + vR.width / 2;
            cY = vR.top + vR.height / 2;
        } else {
            cX = state.input.lastMouseX;
            cY = state.input.lastMouseY;
        }
 
        const s = config.visual.crosshair?.size || 3;
        const color = config.visual?.rainbowMode?.enabled ? 
            `hsl(${state.rainbowHue}, 100%, 50%)` : 
            (config.visual.crosshair?.color || 'lime');
 
        ctx.strokeStyle = color;
        ctx.fillStyle = color;
        ctx.lineWidth = 1;
 
        switch (config.visual.crosshair?.style || 'dot') {
            case 'cross':
                ctx.beginPath();
                ctx.moveTo(cX - 2 * s, cY);
                ctx.lineTo(cX + 2 * s, cY);
                ctx.moveTo(cX, cY - 2 * s);
                ctx.lineTo(cX, cY + 2 * s);
                ctx.stroke();
                break;
            case 'dot':
                ctx.beginPath();
                ctx.arc(cX, cY, s, 0, 2 * Math.PI);
                ctx.fill();
                break;
            case 'circle':
                ctx.beginPath();
                ctx.arc(cX, cY, 2 * s, 0, 2 * Math.PI);
                ctx.stroke();
                break;
        }
    }
 
    function drawTargetLockIndicator(t, vR) {
        if (!config.visual?.targetLock?.enabled || !state.ui.overlayCtx || !t || !vR || !state.gameVideo) return;
 
        const ctx = state.ui.overlayCtx;
        const bbox = t.prediction?.bbox || [0, 0, 0, 0];
        const [vBx, vBy, vBw, vBh] = bbox;
        const bSX = vR.left + vBx / state.gameVideo.videoWidth * vR.width;
        const bSY = vR.top + vBy / state.gameVideo.videoHeight * vR.height;
        const bSW = vBw / state.gameVideo.videoWidth * vR.width;
        const bSH = vBh / state.gameVideo.videoHeight * vR.height;
 
        ctx.strokeStyle = config.visual?.rainbowMode?.enabled ? 
            `hsl(${state.rainbowHue}, 100%, 50%)` : 
            (config.visual.targetLock?.color || 'red');
        ctx.lineWidth = 2;
 
        const cS = 0.2 * Math.min(bSW, bSH);
        switch (config.visual.targetLock?.style || 'full') {
            case 'full':
                ctx.strokeRect(bSX, bSY, bSW, bSH);
                break;
            case 'corners':
                ctx.beginPath();
                ctx.moveTo(bSX + cS, bSY);
                ctx.lineTo(bSX, bSY);
                ctx.lineTo(bSX, bSY + cS);
                ctx.moveTo(bSX + bSW - cS, bSY);
                ctx.lineTo(bSX + bSW, bSY);
                ctx.lineTo(bSX + bSW, bSY + cS);
                ctx.moveTo(bSX + cS, bSY + bSH);
                ctx.lineTo(bSX, bSY + bSH);
                ctx.lineTo(bSX, bSY + bSH - cS);
                ctx.moveTo(bSX + bSW - cS, bSY + bSH);
                ctx.lineTo(bSX + bSW, bSY + bSH);
                ctx.lineTo(bSX + bSW, bSY + bSH - cS);
                ctx.stroke();
                break;
        }
    }
 
    function drawFOVCircle(vR) {
        if (!config.visual?.fovCircle?.enabled || !state.ui.overlayCtx) return;
        if (config.visual.fovCircle?.showOnlyWhenAiming && !state.input.activeKeys.has(config.aim?.activationKey || 'KeyQ')) return;
 
        const ctx = state.ui.overlayCtx;
        let cX, cY;
 
        if (config.visual.fovCircle?.centerOnGameScreen && vR && vR.width > 0) {
            cX = vR.left + vR.width / 2;
            cY = vR.top + vR.height / 2;
        } else {
            cX = state.input.lastMouseX;
            cY = state.input.lastMouseY;
        }
 
        ctx.strokeStyle = config.visual?.rainbowMode?.enabled ? 
            `hsl(${state.rainbowHue}, 100%, 50%)` : 
            (config.visual.fovCircle?.color || 'rgba(255,255,255,0.3)');
        ctx.lineWidth = config.visual.fovCircle?.lineWidth || 1;
        ctx.beginPath();
        ctx.arc(cX, cY, config.aim?.fovRadius || 200, 0, 2 * Math.PI);
        ctx.stroke();
    }
 
    function drawDebugInfo() {
        if (!config.visual?.showDebugInfo || !state.ui.overlayCtx) return;
 
        const ctx = state.ui.overlayCtx;
        ctx.font = '12px Arial';
        ctx.fillStyle = 'rgba(255,255,0,0.8)';
        ctx.fillText(`Backend: ${state.prediction.backend.toUpperCase()}`, 10, 80);
        ctx.fillText(`Mouse: X:${state.input.lastMouseX.toFixed(0)} Y:${state.input.lastMouseY.toFixed(0)}`, 10, 96);
    }
 
    function drawPerformanceMetrics() {
        if (!config.visual?.performanceMetrics?.enabled || !state.ui.overlayCtx) return;
 
        const ctx = state.ui.overlayCtx;
        ctx.font = '14px Arial';
        ctx.fillStyle = 'rgba(0,255,0,0.8)';
        ctx.fillText(`FPS: ${state.performance.fps}`, 10, 20);
        ctx.fillText(`Detect: ${state.performance.detectionTime.toFixed(1)}ms (Avg: ${state.performance.avgDetectionTime.toFixed(1)}ms)`, 10, 36);
        ctx.fillStyle = 'rgba(255, 165, 0, 0.9)';
        ctx.fillText(`Net Latency: ${state.prediction.networkLatency.toFixed(1)}ms`, 10, 52);
 
        if (state.currentTarget && state.prediction.targetHistory[state.currentTarget.id]) {
            const history = state.prediction.targetHistory[state.currentTarget.id];
            ctx.fillText(`Target Vel: X:${(history.smoothedVelocity.x || 0).toFixed(2)} Y:${(history.smoothedVelocity.y || 0).toFixed(2)}`, 10, 68);
        }
    }
 
    function drawIgnoreSelfRegionVisualization(videoRect) {
        if (!config.detection?.ignoreSelfRegion?.enabled || 
            !config.visual?.drawIgnoreRegion?.enabled || 
            !state.ui.overlayCtx || !videoRect || videoRect.width === 0) return;
 
        const ctx = state.ui.overlayCtx;
        const region = config.detection.ignoreSelfRegion || {};
        const visConfig = config.visual.drawIgnoreRegion || {};
 
        const rectX = videoRect.left + videoRect.width * (region.xPercent || 0);
        const rectY = videoRect.top + videoRect.height * (region.yPercent || 0);
        const rectW = videoRect.width * (region.widthPercent || 0);
        const rectH = videoRect.height * (region.heightPercent || 0);
 
        ctx.fillStyle = visConfig.color || 'rgba(50, 50, 50, 0.4)';
        ctx.fillRect(rectX, rectY, rectW, rectH);
    }
 
    function drawVisuals(currentTarget) {
        if (!state.ui.overlayCtx) return;
 
        const ctx = state.ui.overlayCtx;
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
 
        const videoRect = state.gameVideo ? state.gameVideo.getBoundingClientRect() : null;
        const isAimKeyHeld = state.input.activeKeys.has(config.aim?.activationKey || 'KeyQ');
 
        drawCrosshair(videoRect);
 
        if (isAimKeyHeld) {
            drawFOVCircle(videoRect);
 
            if (config.detection?.ignoreSelfRegion?.enabled && 
                config.visual?.drawIgnoreRegion?.enabled && 
                videoRect) {
                drawIgnoreSelfRegionVisualization(videoRect);
            }
 
            if (videoRect && videoRect.width > 0 && currentTarget) {
                drawTargetLockIndicator(currentTarget, videoRect);
            }
        }
 
        if (config.visual?.performanceMetrics?.enabled) drawPerformanceMetrics();
        if (config.visual?.showDebugInfo) drawDebugInfo();
    }
 
    // =================================================================================================
    // DETECTION CORE
    // =================================================================================================
    async function detectPlayers() {
        if (!state.input.activeKeys.has(config.aim?.activationKey || 'KeyQ')) {
            return [];
        }
 
        if (!state.gameVideo || !state.modelLoaded || !state.detectionModel || 
            state.gameVideo.paused || state.gameVideo.ended || state.gameVideo.videoWidth === 0) {
            return [];
        }
 
        if (state.frameCount++ % ((config.detection?.skipFrames || 0) + 1) !== 0) {
            return [];
        }
 
        const now = performance.now();
        if (now - state.lastDetectionTime < (config.detection?.processingInterval || 0)) {
            return [];
        }
 
        let videoSource = state.gameVideo;
 
        if (config.detection?.ignoreSelfRegion?.enabled) {
            if (!state.ui.offscreenCanvas) {
                state.ui.offscreenCanvas = document.createElement('canvas');
                state.ui.offscreenCtx = state.ui.offscreenCanvas.getContext('2d');
            }
 
            if (state.ui.offscreenCanvas.width !== state.gameVideo.videoWidth || 
                state.ui.offscreenCanvas.height !== state.gameVideo.videoHeight) {
                state.ui.offscreenCanvas.width = state.gameVideo.videoWidth;
                state.ui.offscreenCanvas.height = state.gameVideo.videoHeight;
            }
 
            const ctx = state.ui.offscreenCtx;
            ctx.drawImage(state.gameVideo, 0, 0, state.gameVideo.videoWidth, state.gameVideo.videoHeight);
 
            const region = config.detection.ignoreSelfRegion || {};
            ctx.fillStyle = 'rgba(0, 0, 0, 1)';
            ctx.fillRect(
                state.gameVideo.videoWidth * (region.xPercent || 0),
                state.gameVideo.videoHeight * (region.yPercent || 0),
                state.gameVideo.videoWidth * (region.widthPercent || 0),
                state.gameVideo.videoHeight * (region.heightPercent || 0)
            );
 
            videoSource = state.ui.offscreenCanvas;
        }
 
        try {
            const detectionStart = performance.now();
            const poses = await state.detectionModel.estimatePoses(videoSource, { flipHorizontal: false });
 
            state.performance.detectionTime = performance.now() - detectionStart;
            state.performance.detectionTimeHistory.push(state.performance.detectionTime);
 
            if (state.performance.detectionTimeHistory.length > 30) {
                state.performance.detectionTimeHistory.shift();
            }
 
            state.performance.avgDetectionTime = state.performance.detectionTimeHistory.reduce((a, b) => a + b, 0) / 
                                              state.performance.detectionTimeHistory.length;
            state.lastDetectionTime = now;
 
            const results = [];
            if (poses && poses.length > 0) {
                for (const pose of poses) {
                    if (pose.score && pose.score >= (config.detection?.detectorConfig?.minPoseScore || 0)) {
                        const bbox = calculateBoundingBoxFromKeypoints(pose.keypoints);
                        if (bbox && bbox.width > 0 && bbox.height > 0) {
                            results.push({
                                class: 'person',
                                score: pose.score,
                                bbox: [bbox.x, bbox.y, bbox.width, bbox.height],
                                keypoints: pose.keypoints
                            });
                        }
                    }
                }
            }
 
            return results.slice(0, config.detection?.maxDetections || 1);
        } catch (err) {
            debug.error("Error during pose estimation:", err);
            return [];
        }
    }
 
    // =================================================================================================
    // AIMING LOGIC
    // =================================================================================================
    async function processAiming(timestamp) {
        const isAimKeyHeld = state.input.activeKeys.has(config.aim?.activationKey || 'KeyQ');
        const now = performance.now();
 
        if (!isAimKeyHeld || !config.detection?.enabled || !state.modelLoaded) {
            state.currentTarget = null;
            drawVisuals(null);
            if (state.isShooting) InputController.stopShooting();
            return;
        }
 
        const players = await detectPlayers();
        const newTarget = findBestTarget(players);
 
        updateTargetPrediction(newTarget);
 
        if (newTarget) {
            if (!state.currentTarget || newTarget.prediction !== state.currentTarget.prediction) {
                if (!state.currentTarget || now - state.lastTargetSwitch > (config.aim?.targetSwitchCooldown || 0)) {
                    state.currentTarget = newTarget;
                    state.lastTargetSwitch = now;
                }
            } else {
                state.currentTarget = newTarget;
            }
        } else {
            state.currentTarget = null;
        }
 
        drawVisuals(state.currentTarget);
 
        if (state.currentTarget) {
            let { x: targetX, y: targetY } = state.currentTarget.screenPosition || { x: 0, y: 0 };
 
            // Get predicted position if prediction is enabled
            if (config.aim.prediction.enabled) {
                const predictedPos = calculatePredictedPosition(state.currentTarget.id);
                if (predictedPos) {
                    targetX = predictedPos.x;
                    targetY = predictedPos.y;
                }
            }
 
            let finalX = targetX;
            let finalY = targetY;
 
            const speedPercent = config.aim?.aimSpeed?.speedPercent || 85;
 
            if (config.aim?.aimSpeed?.enabled && speedPercent < 100) {
                const videoRect = state.gameVideo?.getBoundingClientRect();
                if (videoRect && videoRect.width > 0) {
                    const referenceX = videoRect.left + videoRect.width / 2;
                    const referenceY = videoRect.top + videoRect.height / 2;
                    const speedDecimal = speedPercent / 100.0;
 
                    finalX = referenceX + (targetX - referenceX) * speedDecimal;
                    finalY = referenceY + (targetY - referenceY) * speedDecimal;
                }
            }
 
            InputController.moveMouseTo(finalX, finalY);
 
            if (config.game?.autoShoot && state.currentTarget.distance < (config.aim?.fovRadius || 200) * (config.aim?.triggerThreshold || 0.7)) {
                if (!state.isShooting) {
                    setTimeout(() => {
                        if (state.currentTarget && state.input.activeKeys.has(config.aim?.activationKey || 'KeyQ')) {
                            InputController.startShooting();
                        }
                    }, config.game?.triggerOptions?.delayBeforeShoot || 0);
                }
            } else if (state.isShooting) {
                InputController.stopShooting();
            }
        } else {
            if (state.isShooting) InputController.stopShooting();
        }
    }
 
    // =================================================================================================
    // MAIN LOOP
    // =================================================================================================
    function startAimbotLoop() {
        async function mainLoop(timestamp) {
            requestAnimationFrame(mainLoop);
 
            state.performance.framesThisSecond++;
            if (timestamp - state.performance.lastFpsUpdate >= 1000) {
                state.performance.fps = state.performance.framesThisSecond;
                state.performance.framesThisSecond = 0;
                state.performance.lastFpsUpdate = timestamp;
            }
 
            if (config.visual?.rainbowMode?.enabled) {
                state.rainbowHue = (timestamp * (config.visual.rainbowMode?.speed || 0.1)) % 360;
            }
 
            if (!state.gameVideo || state.gameVideo.paused || state.gameVideo.ended || state.gameVideo.videoWidth === 0) {
                if (state.isShooting) InputController.stopShooting();
                if (state.ui.overlayCtx) state.ui.overlayCtx.clearRect(0, 0, state.ui.overlayCanvas.width, state.ui.overlayCanvas.height);
                state.currentTarget = null;
                return;
            }
 
            await processAiming(timestamp);
        }
 
        requestAnimationFrame(mainLoop);
    }
 
    // =================================================================================================
    // INITIALIZATION
    // =================================================================================================
    async function initializeAimbot() {
        debug.log(`Initializing Capybara AI Aimbot...`);
 
        state.gameVideo = document.querySelector(config.game?.videoSelector || 'video');
        if (!state.gameVideo) {
            debug.error("Game video element not found. Retrying...");
            setTimeout(initializeAimbot, 3000);
            return;
        }
 
        createOverlayCanvas();
 
        // Performance monitoring worker
        const workerBlob = new Blob(['// Dummy Worker'], { type: 'application/javascript' });
        const workerUrl = URL.createObjectURL(workerBlob);
        new Worker(workerUrl);
 
        // Network latency observer
        const observer = new PerformanceObserver((list) => {
            const lastEntry = list.getEntries().pop();
            if (lastEntry && lastEntry.name.includes('.svg')) {
                state.prediction.networkLatency = lastEntry.duration;
            }
        });
        observer.observe({ type: "resource", buffered: true });
 
        InputController.init();
 
        if (config.detection?.enabled) {
            await loadDetectionModel();
        }
 
        startAimbotLoop();
        debug.log("Initialization complete. Capybara AI Aimbot is now active.");
        showNotification(`Capybara AI Aimbot Initialized! (${state.prediction.backend.toUpperCase()})`, "info");
    }
 
    // Start the aimbot
    if (document.readyState === 'complete' || document.readyState === 'interactive') {
        setTimeout(initializeAimbot, 2500);
    } else {
        window.addEventListener('load', () => setTimeout(initializeAimbot, 2500));
    }
})();
