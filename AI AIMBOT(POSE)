// ==UserScript==
// @name         Fortnite xCloud Precision Aimbot (MoveNet) - Optimized
// @description  AI-powered aimbot for Fortnite on xCloud with MoveNet pose detection, optimized for performance.
// @author       Improved Version / Community
// @version      4.2.19
// @match        *://*.xbox.com/play/*
// @grant        none
// @run-at       document-end
// @require      https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core@3.18.0/dist/tf-core.min.js
// @require      https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter@3.18.0/dist/tf-converter.min.js
// @require      https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@3.18.0/dist/tf-backend-webgl.min.js
// @require      https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.0.0/dist/pose-detection.min.js
// ==/UserScript==

(function() {
    'use strict';

    // ### Configuration
    const config = {
        detection: {
            enabled: true,
            modelType: poseDetection.SupportedModels.MoveNet,
            detectorConfig: {
                modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING,
                enableSmoothing: true,
                minPoseScore: 0.25
            },
            keypointConfidence: 0.20,
            maxDetections: 5,
            processingInterval: 30,
            skipFrames: 1,
            useWebGL2: true,
            ignoreSelfRegion: {
                enabled: true,
                xPercent: 0.00,
                yPercent: 0.27,
                widthPercent: 0.37,
                heightPercent: 0.74
            }
        },
        game: {
            videoSelector: 'video[aria-label="Game Stream for unknown title"]',
            containerSelector: '#game-stream',
            recoilCompensation: true,
            recoilLevel: 1,
            recoilPatterns: {
                1: { vertical: 0.1, horizontal: 0.02, recoverySpeed: 0.25 },
                2: { vertical: 0.2, horizontal: 0.04, recoverySpeed: 0.20 },
                3: { vertical: 0.3, horizontal: 0.06, recoverySpeed: 0.15 },
                4: { vertical: 0.5, horizontal: 0.1, recoverySpeed: 0.12 },
                5: { vertical: 0.7, horizontal: 0.15, recoverySpeed: 0.10 }
            },
            autoShoot: true,
            triggerOptions: {
                delayBeforeShoot: 10,
                burstMode: false,
                burstCount: 3,
                burstInterval: 100
            },
            controlOptions: {
                crouchOnShoot: false,
                crouchKey: 'KeyC',
                reloadKey: 'KeyR',
                weaponKeys: ['Digit1', 'Digit2', 'Digit3', 'Digit4', 'Digit5']
            }
        },
        aim: {
            activationKey: 'KeyE',
            fovRadius: 250,
            instantLock: true,
            aimPoint: "torso_center",
            headOffset: 0.15,
            bodyOffset: 0.4,
            targetPriority: "center",
            targetSwitchCooldown: 250,
            triggerThreshold: 0.7,
            smoothing: { enabled: false, amount: 0.15, extrapolation: false },
            snapOptions: { strength: 1, threshold: 0.9, diminishingRange: false }
        },
        visual: {
            showDebugInfo: true,
            crosshair: { enabled: true, style: 'dot', color: 'lime', size: 3, centerOnGameScreen: true },
            boundingBoxes: { enabled: false },
            keypoints: { enabled: true, color: 'cyan', radius: 3 },
            skeleton: { enabled: true, color: 'rgba(255, 0, 255, 0.9)', lineWidth: 2 },
            targetLock: { enabled: true, color: 'yellow', style: 'corners' },
            fovCircle: { enabled: true, color: 'rgba(255,255,255,0.3)', lineWidth: 1, centerOnGameScreen: true, showOnlyWhenAiming: true },
            performanceMetrics: { enabled: true, position: 'top-left' },
            drawIgnoreRegion: { enabled: true, color: 'rgba(50, 50, 50, 0.4)', lineWidth: 1, showOnlyWhenAiming: true },
            showRecoilTunerGUI: false
        }
    };
    config.version = '4.2.19';

    // ### State Management
    const tfState = { backend: 'webgl', flags: { WEBGL_VERSION: 2, WEBGL_RENDER_FLOAT32_ENABLED: true } };
    const state = {
        gameVideo: null,
        detectionModel: null,
        modelLoaded: false,
        currentTarget: null,
        lastTargetSwitch: 0,
        frameCount: 0,
        lastDetectionTime: 0,
        performance: { fps: 0, framesThisSecond: 0, lastFpsUpdate: 0, detectionTime: 0, avgDetectionTime: 0, detectionTimeHistory: [] },
        ui: { overlayCanvas: null, overlayCtx: null, offscreenCanvas: null, offscreenCtx: null },
        input: { lastMouseX: window.innerWidth / 2, lastMouseY: window.innerHeight / 2, leftButtonDown: false, rightButtonDown: false, activeKeys: new Set() },
        recoilState: { active: false, offsetX: 0, offsetY: 0, shotsFired: 0, lastShotTime: 0, lastLeftButtonState: false },
        isShooting: false,
        currentWeapon: 0,
        dynamicSkipFrames: 0 // Added for performance optimization
    };

    const debug = {
        log: (...args) => console.log(`[AimbotV${config.version}-MoveNet]`, ...args),
        warn: (...args) => console.warn(`[AimbotV${config.version}-MoveNet]`, ...args),
        error: (...args) => console.error(`[AimbotV${config.version}-MoveNet]`, ...args)
    };

    // ### Utility Functions
    function showNotification(message, type = 'info', duration = 3000) {
        const n = document.createElement('div');
        n.style.cssText = `position:fixed;top:20px;left:50%;transform:translateX(-50%);padding:10px 20px;border-radius:5px;color:white;z-index:1000000;font-family:sans-serif;font-size:16px;box-shadow:0 2px 10px rgba(0,0,0,0.2);background-color:${type === 'error' ? 'rgba(255,0,0,0.8)' : type === 'warning' ? 'rgba(255,165,0,0.8)' : 'rgba(0,0,0,0.7)'};`;
        n.textContent = message;
        document.body.appendChild(n);
        setTimeout(() => n.remove(), duration);
    }

    async function setupTensorFlow() {
        try {
            debug.log("Configuring TF.js...");
            await tf.setBackend(tfState.backend);
            await tf.ready();
            for (const f in tfState.flags) tf.env().set(f, tfState.flags[f]);
            debug.log(`TF.js backend: ${tf.getBackend()}`);
            const sT = performance.now();
            const tT = tf.zeros([100, 100, 3]);
            await tT.data();
            tT.dispose();
            debug.log(`TF basic op test: ${(performance.now() - sT).toFixed(2)}ms`);
            return true;
        } catch (e) {
            debug.error("TF setup failed:", e);
            return false;
        }
    }

    async function loadDetectionModel() {
        debug.log("Loading MoveNet model...");
        try {
            if (!await setupTensorFlow()) throw Error("TF setup failed");
            if (typeof poseDetection === "undefined") throw Error("Pose Detection API not loaded.");
            state.detectionModel = await poseDetection.createDetector(config.detection.modelType, config.detection.detectorConfig);
            const tC = document.createElement('canvas');
            tC.width = 192;
            tC.height = 192;
            await state.detectionModel.estimatePoses(tC);
            state.modelLoaded = true;
            debug.log("MoveNet model loaded!");
            showNotification("AI Model (MoveNet) Loaded!", "info");
            return true;
        } catch (e) {
            debug.error("Failed to load MoveNet model:", e);
            showNotification("Error loading AI model (MoveNet)! Check console.", "error");
            return false;
        }
    }

    // ### Detection and Targeting
    function calculateBoundingBoxFromKeypoints(kps) {
        if (!kps || kps.length === 0) return null;
        let mX = Infinity, mY = Infinity, mAX = -Infinity, mAY = -Infinity, vK = 0;
        kps.forEach(k => {
            if (k.score && k.score >= config.detection.keypointConfidence) {
                mX = Math.min(mX, k.x);
                mY = Math.min(mY, k.y);
                mAX = Math.max(mAX, k.x);
                mAY = Math.max(mAY, k.y);
                vK++;
            }
        });
        if (vK < 5) return null;
        const w = mAX - mX, h = mAY - mY, pX = 0.1 * w, pY = 0.1 * h;
        return { x: Math.max(0, mX - pX), y: Math.max(0, mY - pY), width: mAX - mX + 2 * pX, height: mAY - mY + 2 * pY, validKeypoints: vK };
    }

    function calculateAimTarget(pred, vRect) {
        const [vBx, vBy, vBw, vBh] = pred.bbox;
        const sBx = vRect.left + vBx / state.gameVideo.videoWidth * vRect.width;
        const sBy = vRect.top + vBy / state.gameVideo.videoHeight * vRect.height;
        const sBw = vBw / state.gameVideo.videoWidth * vRect.width;
        const sBh = vBh / state.gameVideo.videoHeight * vRect.height;
        let tX, tY;
        const kps = pred.keypoints;
        const gK = n => kps.find(k => k.name === n && k.score >= config.detection.keypointConfidence);
        switch (config.aim.aimPoint) {
            case "head":
                const n = gK('nose'), lE = gK('left_eye'), rE = gK('right_eye');
                if (n) {
                    tX = vRect.left + n.x / state.gameVideo.videoWidth * vRect.width;
                    tY = vRect.top + n.y / state.gameVideo.videoHeight * vRect.height;
                } else if (lE && rE) {
                    tX = vRect.left + ((lE.x + rE.x) / 2) / state.gameVideo.videoWidth * vRect.width;
                    tY = vRect.top + ((lE.y + rE.y) / 2) / state.gameVideo.videoHeight * vRect.height;
                } else {
                    tX = sBx + sBw / 2;
                    tY = sBy + sBh * config.aim.headOffset;
                }
                break;
            case "neck":
                const lS_n = gK('left_shoulder'), rS_n = gK('right_shoulder');
                if (lS_n && rS_n) {
                    tX = vRect.left + ((lS_n.x + rS_n.x) / 2) / state.gameVideo.videoWidth * vRect.width;
                    tY = vRect.top + ((lS_n.y + rS_n.y) / 2 - vBh * 0.05) / state.gameVideo.videoHeight * vRect.height;
                } else {
                    tX = sBx + sBw / 2;
                    tY = sBy + sBh * (config.aim.headOffset + 0.1);
                }
                break;
            case "torso_center":
                const lS_t = gK('left_shoulder'), rS_t = gK('right_shoulder'), lH_t = gK('left_hip'), rH_t = gK('right_hip');
                if (lS_t && rS_t && lH_t && rH_t) {
                    tX = vRect.left + (((lS_t.x + rS_t.x) / 2 + (lH_t.x + rH_t.x) / 2) / 2) / state.gameVideo.videoWidth * vRect.width;
                    tY = vRect.top + (((lS_t.y + rS_t.y) / 2 + (lH_t.y + rH_t.y) / 2) / 2) / state.gameVideo.videoHeight * vRect.height;
                } else {
                    tX = sBx + sBw / 2;
                    tY = sBy + sBh * config.aim.bodyOffset;
                }
                break;
            case "center":
            default:
                tX = sBx + sBw / 2;
                tY = sBy + sBh / 2;
                break;
        }
        return { x: tX, y: tY, width: sBw, height: sBh, bboxRaw: pred.bbox, keypoints: pred.keypoints };
    }

    function findBestTarget(predictions) {
        if (!predictions || predictions.length === 0 || !state.gameVideo) return null;
        const videoRect = state.gameVideo.getBoundingClientRect();
        if (!videoRect || videoRect.width === 0) return null;
        const gameScreenCenterX = videoRect.left + videoRect.width / 2;
        const gameScreenCenterY = videoRect.top + videoRect.height / 2;
        let bestTarget = null;
        let bestScore = Infinity;
        predictions.forEach(prediction => {
            const targetInfo = calculateAimTarget(prediction, videoRect);
            let referenceX, referenceY;
            if (config.aim.targetPriority === "center") {
                referenceX = gameScreenCenterX;
                referenceY = gameScreenCenterY;
            } else {
                referenceX = state.input.lastMouseX;
                referenceY = state.input.lastMouseY;
            }
            const dx = targetInfo.x - referenceX;
            const dy = targetInfo.y - referenceY;
            const distanceToPriorityPoint = Math.sqrt(dx * dx + dy * dy);
            let fovCenterX = config.visual.fovCircle.centerOnGameScreen && videoRect ? gameScreenCenterX : state.input.lastMouseX;
            let fovCenterY = config.visual.fovCircle.centerOnGameScreen && videoRect ? gameScreenCenterY : state.input.lastMouseY;
            const dx_fov = targetInfo.x - fovCenterX;
            const dy_fov = targetInfo.y - fovCenterY;
            if (Math.sqrt(dx_fov * dx_fov + dy_fov * dy_fov) > config.aim.fovRadius) return;
            let score;
            switch (config.aim.targetPriority) {
                case "size":
                    score = targetInfo.width * targetInfo.height > 0 ? 1 / (targetInfo.width * targetInfo.height) : Infinity;
                    break;
                case "distance":
                case "center":
                case "crosshair":
                default:
                    score = distanceToPriorityPoint;
                    break;
            }
            if (score < bestScore) {
                bestScore = score;
                bestTarget = { prediction, screenPosition: targetInfo, distance: distanceToPriorityPoint, score: prediction.score };
            }
        });
        return bestTarget;
    }

    // ### Input Controller
    const InputController = {
        init() {
            state.input.lastMouseX = window.innerWidth / 2;
            state.input.lastMouseY = window.innerHeight / 2;
            document.addEventListener('mousemove', e => {
                state.input.lastMouseX = e.clientX;
                state.input.lastMouseY = e.clientY;
            });
            this.setupKeyMonitoring();
            debug.log("Input controller initialized");
            return true;
        },
        setupKeyMonitoring() {
            document.addEventListener('keydown', e => {
                state.input.activeKeys.add(e.code);
                if (e.code === config.aim.activationKey) debug.log(`Aim activation key (${e.code}) pressed.`);
            });
            document.addEventListener('keyup', e => state.input.activeKeys.delete(e.code));
            document.addEventListener('mousedown', e => {
                if (e.button === 0) state.input.leftButtonDown = true;
                if (e.button === 2) state.input.rightButtonDown = true;
            });
            document.addEventListener('mouseup', e => {
                if (e.button === 0) state.input.leftButtonDown = false;
                if (e.button === 2) state.input.rightButtonDown = false;
            });
        },
        moveMouseTo(tSX, tSY) {
            if (!state.gameVideo) return;
            const vR = state.gameVideo.getBoundingClientRect();
            if (!vR || vR.width === 0) return;
            const gVCX = vR.left + vR.width / 2;
            const gVCY = vR.top + vR.height / 2;
            let mX = tSX - gVCX;
            let mY = tSY - gVCY;
            if (Math.abs(mX) < 0.1 && Math.abs(mY) < 0.1 && state.recoilState.offsetX === 0 && state.recoilState.offsetY === 0) return;
            const sC = document.querySelector(config.game.containerSelector) || state.gameVideo || document.documentElement;
            const evt = new PointerEvent('pointermove', {
                bubbles: true, cancelable: true, view: window,
                clientX: Math.round(state.input.lastMouseX + mX), clientY: Math.round(state.input.lastMouseY + mY),
                movementX: Math.round(mX), movementY: Math.round(mY),
                buttons: (state.input.leftButtonDown ? 1 : 0) | (state.input.rightButtonDown ? 2 : 0),
                pointerType: 'mouse', isPrimary: true
            });
            sC.dispatchEvent(evt);
        },
        startShooting() {
            if (state.isShooting) return;
            const sC = document.querySelector(config.game.containerSelector) || state.gameVideo || document.documentElement;
            const evt = new PointerEvent('pointerdown', {
                bubbles: true, cancelable: true, view: window,
                clientX: Math.round(state.input.lastMouseX), clientY: Math.round(state.input.lastMouseY),
                button: 0, buttons: 1, pointerType: 'mouse', isPrimary: true
            });
            sC.dispatchEvent(evt);
            state.isShooting = true;
            state.recoilState.shotsFired = 0;
            debug.log("Shooting started");
        },
        stopShooting() {
            if (!state.isShooting) return;
            const sC = document.querySelector(config.game.containerSelector) || state.gameVideo || document.documentElement;
            const evt = new PointerEvent('pointerup', {
                bubbles: true, cancelable: true, view: window,
                clientX: Math.round(state.input.lastMouseX), clientY: Math.round(state.input.lastMouseY),
                button: 0, buttons: 0, pointerType: 'mouse', isPrimary: true
            });
            sC.dispatchEvent(evt);
            state.isShooting = false;
            debug.log("Shooting stopped");
        }
    };

    // ### Visual Rendering
    function createOverlayCanvas() {
        if (state.ui.overlayCanvas) return;
        const c = document.createElement('canvas');
        c.id = 'xcloud-aimbot-overlay';
        c.width = window.innerWidth;
        c.height = window.innerHeight;
        c.style.cssText = 'position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:99999;';
        state.ui.overlayCanvas = c;
        state.ui.overlayCtx = c.getContext('2d');
        document.body.appendChild(c);
        window.addEventListener('resize', () => {
            c.width = window.innerWidth;
            c.height = window.innerHeight;
        });
    }

    function drawVisuals(players, currentTarget) {
        if (!state.ui.overlayCtx) return;
        const ctx = state.ui.overlayCtx;
        const canvas = state.ui.overlayCanvas;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const videoRect = state.gameVideo ? state.gameVideo.getBoundingClientRect() : null;
        const isAimKeyHeld = state.input.activeKeys.has(config.aim.activationKey);
        if (config.visual.crosshair.enabled) {
            let cX = config.visual.crosshair.centerOnGameScreen && videoRect ? videoRect.left + videoRect.width / 2 : state.input.lastMouseX;
            let cY = config.visual.crosshair.centerOnGameScreen && videoRect ? videoRect.top + videoRect.height / 2 : state.input.lastMouseY;
            ctx.fillStyle = config.visual.crosshair.color;
            ctx.beginPath();
            ctx.arc(cX, cY, config.visual.crosshair.size, 0, 2 * Math.PI);
            ctx.fill();
        }
        if (config.visual.fovCircle.enabled && (!config.visual.fovCircle.showOnlyWhenAiming || isAimKeyHeld) && videoRect) {
            let cX = config.visual.fovCircle.centerOnGameScreen ? videoRect.left + videoRect.width / 2 : state.input.lastMouseX;
            let cY = config.visual.fovCircle.centerOnGameScreen ? videoRect.top + videoRect.height / 2 : state.input.lastMouseY;
            ctx.strokeStyle = config.visual.fovCircle.color;
            ctx.lineWidth = config.visual.fovCircle.lineWidth;
            ctx.beginPath();
            ctx.arc(cX, cY, config.aim.fovRadius, 0, 2 * Math.PI);
            ctx.stroke();
        }
        if (isAimKeyHeld && videoRect && videoRect.width > 0) {
            players.forEach(p => {
                if (p.keypoints) {
                    p.keypoints.forEach(kP => {
                        if (kP.score >= config.detection.keypointConfidence) {
                            const sX = videoRect.left + kP.x / state.gameVideo.videoWidth * videoRect.width;
                            const sY = videoRect.top + kP.y / state.gameVideo.videoHeight * vRect.height;
                            ctx.beginPath();
                            ctx.arc(sX, sY, config.visual.keypoints.radius, 0, 2 * Math.PI);
                            ctx.fillStyle = config.visual.keypoints.color;
                            ctx.fill();
                        }
                    });
                }
            });
            if (currentTarget) {
                const [vBx, vBy, vBw, vBh] = currentTarget.prediction.bbox;
                const bSX = videoRect.left + vBx / state.gameVideo.videoWidth * videoRect.width;
                const bSY = videoRect.top + vBy / state.gameVideo.videoHeight * videoRect.height;
                const bSW = vBw / state.gameVideo.videoWidth * videoRect.width;
                const bSH = vBh / state.gameVideo.videoHeight * videoRect.height;
                ctx.strokeStyle = config.visual.targetLock.color;
                ctx.lineWidth = 2;
                const cS = 0.2 * Math.min(bSW, bSH);
                ctx.beginPath();
                ctx.moveTo(bSX + cS, bSY); ctx.lineTo(bSX, bSY); ctx.lineTo(bSX, bSY + cS);
                ctx.moveTo(bSX + bSW - cS, bSY); ctx.lineTo(bSX + bSW, bSY); ctx.lineTo(bSX + bSW, bSY + cS);
                ctx.moveTo(bSX + cS, bSY + bSH); ctx.lineTo(bSX, bSY + bSH); ctx.lineTo(bSX, bSY + bSH - cS);
                ctx.moveTo(bSX + bSW - cS, bSY + bSH); ctx.lineTo(bSX + bSW, bSY + bSH); ctx.lineTo(bSX + bSW, bSY + bSH - cS);
                ctx.stroke();
            }
        }
        if (config.visual.performanceMetrics.enabled) {
            ctx.font = '14px Arial';
            ctx.fillStyle = 'rgba(0,255,0,0.8)';
            ctx.fillText(`FPS: ${state.performance.fps}`, 10, 20);
            ctx.fillText(`Detect: ${state.performance.detectionTime.toFixed(1)}ms`, 10, 36);
        }
    }

    // ### Aiming and Detection Logic
    async function detectPlayers() {
        if (!state.gameVideo || !state.modelLoaded || !state.detectionModel || state.gameVideo.paused || state.gameVideo.videoWidth === 0) return [];
        
        // Dynamic frame skipping for performance
        if (state.performance.avgDetectionTime > 50) {
            state.dynamicSkipFrames = Math.min(state.dynamicSkipFrames + 1, 5);
        } else {
            state.dynamicSkipFrames = Math.max(state.dynamicSkipFrames - 1, 0);
        }

        if (state.frameCount % (config.detection.skipFrames + state.dynamicSkipFrames + 1) !== 0) {
            state.frameCount++;
            return [];
        }
        state.frameCount++;

        const now = performance.now();
        if (now - state.lastDetectionTime < config.detection.processingInterval) return [];

        let videoSource = state.gameVideo;
        if (config.detection.ignoreSelfRegion.enabled) {
            if (!state.ui.offscreenCanvas) {
                state.ui.offscreenCanvas = document.createElement('canvas');
                state.ui.offscreenCtx = state.ui.offscreenCanvas.getContext('2d');
            }
            state.ui.offscreenCanvas.width = state.gameVideo.videoWidth;
            state.ui.offscreenCanvas.height = state.gameVideo.videoHeight;
            const ctx = state.ui.offscreenCtx;
            ctx.drawImage(state.gameVideo, 0, 0);
            const region = config.detection.ignoreSelfRegion;
            ctx.fillStyle = 'black';
            ctx.fillRect(state.gameVideo.videoWidth * region.xPercent, state.gameVideo.videoHeight * region.yPercent,
                         state.gameVideo.videoWidth * region.widthPercent, state.gameVideo.videoHeight * region.heightPercent);
            videoSource = state.ui.offscreenCanvas;
        }

        try {
            const detectionStart = performance.now();
            const poses = await state.detectionModel.estimatePoses(videoSource, { 
                flipHorizontal: false, 
                maxPoses: config.detection.maxDetections // Performance optimization
            });
            const detectionEnd = performance.now();
            state.performance.detectionTime = detectionEnd - detectionStart;
            state.performance.detectionTimeHistory.push(state.performance.detectionTime);
            if (state.performance.detectionTimeHistory.length > 30) state.performance.detectionTimeHistory.shift();
            state.performance.avgDetectionTime = state.performance.detectionTimeHistory.reduce((a, b) => a + b, 0) / state.performance.detectionTimeHistory.length;
            state.lastDetectionTime = now;
            const results = [];
            if (poses && poses.length > 0) {
                for (const pose of poses) {
                    if (pose.score >= config.detection.detectorConfig.minPoseScore) {
                        const bbox = calculateBoundingBoxFromKeypoints(pose.keypoints);
                        if (bbox) results.push({ class: 'person', score: pose.score, bbox: [bbox.x, bbox.y, bbox.width, bbox.height], keypoints: pose.keypoints });
                    }
                }
            }
            return results.slice(0, config.detection.maxDetections);
        } catch (err) {
            debug.error("Pose estimation error:", err);
            return [];
        }
    }

    async function processAiming() {
        const isAimKeyHeld = state.input.activeKeys.has(config.aim.activationKey);
        if (!isAimKeyHeld || !config.detection.enabled || !state.modelLoaded) {
            state.currentTarget = null;
            drawVisuals([], null);
            if (state.isShooting) InputController.stopShooting();
            return;
        }
        const players = await detectPlayers();
        const newTarget = findBestTarget(players);
        if (newTarget && (!state.currentTarget || performance.now() - state.lastTargetSwitch > config.aim.targetSwitchCooldown)) {
            state.currentTarget = newTarget;
            state.lastTargetSwitch = performance.now();
        }
        drawVisuals(players, state.currentTarget);
        if (state.currentTarget) {
            InputController.moveMouseTo(state.currentTarget.screenPosition.x, state.currentTarget.screenPosition.y);
            if (config.game.autoShoot && state.currentTarget.distance < config.aim.fovRadius * config.aim.triggerThreshold) {
                if (!state.isShooting) {
                    setTimeout(() => {
                        if (state.currentTarget && state.input.activeKeys.has(config.aim.currentTarget)) {
                            InputController.startShooting();
                        }
                    }, config.game.triggerOptions.delayBeforeShoot);
                }
            } else if (state.isShooting) {
                InputController.stopShooting();
            }
        } else if (state.isShooting) {
            InputController.stopShooting();
        }
    }

    // ### Initialization
    function startAimbotLoop() {
        debug.log("Starting aimbot loop");
        let loopActive = true;
        async function mainLoop(timestamp) {
            if (!loopActive) return;
            requestAnimationFrame(mainLoop);
            state.performance.framesThisSecond++;
            if (timestamp - state.performance.lastFpsUpdate >= 1000) {
                state.performance.fps = state.performance.framesThisSecond;
                state.performance.framesThisSecond = 0;
                state.performance.lastFpsUpdate = timestamp;
            }
            if (!state.gameVideo || state.gameVideo.paused || state.gameVideo.videoWidth === 0) {
                if (state.isShooting) InputController.stopShooting();
                if (state.ui.overlayCtx) state.ui.overlayCtx.clearRect(0, state.ui.overlayCanvas.width, state.ui.overlayCanvas.height);
                state.currentTarget = null;
                return;
            }
            await processAiming();
        }
        requestAnimationFrame(mainLoop);
    }

    async function initializeAimbot() {
        debug.log(`Initializing Aimbot V${config.version}...`);
        state.gameVideo = document.querySelector(config.game.videoSelector);
        if (!state.gameVideo) {
            debug.error("Game video not found. Retrying...");
            showNotification("Error: Game video not found!", "error", 5000);
            setTimeout(initializeAimbot, 3000);
            return;
        }
        createOverlayCanvas();
        if (!InputController.init()) {
            debug.error("Input controller failed to initialize.");
            showNotification("Error: Input controller init failed!", "error");
            return;
        }
        if (config.detection.enabled) {
            if (!await loadDetectionModel()) debug.error("Detection model failed to load.");
        }
        startAimbotLoop();
        showNotification(`Precision Aimbot V${config.version} Initialized`, "info");
    }

    if (document.readyState === 'complete' || document.readyState === 'interactive') {
        setTimeout(initializeAimbot, 2500);
    } else {
        window.addEventListener('load', () => setTimeout(initializeAimbot, 2500));
    }
})();
