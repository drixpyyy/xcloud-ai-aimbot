(function() {
    'use strict';

    // =================================================================================================
    // CONFIGURATION
    // =================================================================================================
    const config = {
        detection: {
            enabled: true, // Toggles AI detection on/off
            betterDetection: {
                enabled: true // If true, detects all players on screen for ESP, gives better detection long range
            },
            modelType: poseDetection.SupportedModels.MoveNet, // AI model for pose detection
            detectorConfig: {
                modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING, // LIGHTNING is faster but the dataset is worse THUNDER is slower but dataset is better so it can improve detection but i recommend you only use THUNDER for good laptops but it doesnt really matter
                enableSmoothing: true, // Smooths detection across frames
                minPoseScore: 0.25 // Minimum confidence score for pose detection
            },
            keypointConfidence: 0.20, // Minimum confidence for individual keypoints
            maxDetections: 5, // Maximum number of players to detect on screen
            processingInterval: 5, // Process every Nth frame for performance
            skipFrames: 2, // Additional frames to skip for performance
            ignoreSelfRegion: { // Area of the screen to ignore for detection
                enabled: true,
                xPercent: 0.00,
                yPercent: 0.27,
                widthPercent: 0.37,
                heightPercent: 0.74
            }
        },
        game: {
            videoSelector: 'video[aria-label="Game Stream for unknown title"]', // CSS selector for the game video element
            containerSelector: '#game-stream', // CSS selector for the game container element
            autoShoot: false, // Enables automatic shooting when a target is locked
            triggerOptions: {
                delayBeforeShoot: 10, // Delay in milliseconds before shooting
                burstMode: false, // Enables burst fire mode
                burstCount: 3, // Number of shots in a burst
                burstInterval: 100 // Interval in milliseconds between burst shots
            }
        },
        aim: {
            activationKey: 'KeyQ', // Hotkey to activate the aimbot
            fovRadius: 150, // Radius in pixels for target acquisition
            aimPoint: "torso_center", // Body part to aim at
            headOffset: 0.15, // Vertical offset for head aiming
            bodyOffset: 0.4, // Vertical offset for body aiming
            targetPriority: "center", // Prioritizes targets near the screen center or mouse
            targetSwitchCooldown: 0.1, // Cooldown in seconds before switching to a new target
            triggerThreshold: 0.7, // Proximity to the center required for auto-shooting
            aimSpeed: {
                enabled: true,
                speedPercent: 45.0
            },
            smartSlowdown: {
                enabled: true,
                maxSpeed: 100.0,
                minSpeed: 25.0,
                slowdownRadius: 90,
                nonlinear: {
                    enabled: true,
                    exponent: 2.0
                },
                prediction: {
                    enabled: true
                }
            },
            prediction: {
                enabled: false,
                latencyCompensation: 50,
                jitterBufferSize: 3,
                maxVelocity: 1000,
                smoothingFactor: 0.2,
                predictionScale: 1.2
            }
        },
        visual: {
            showDebugInfo: true, // Shows technical information overlay
            crosshair: {
                enabled: true,
                style: 'dot', // 'dot', 'cross', 'circle'
                color: 'black',
                size: 3,
                centerOnGameScreen: true
            },
            targetLock: {
                enabled: false,
                style: 'full', // 'full', 'corners'
                color: 'red',
                lineWidth: 2,
                fillEnabled: true,
                fillColor: 'rgba(255, 0, 0, 0.2)', // Use RGBA to set color and transparency
                gradient: {
                    enabled: true,
                    speed: 0.5
                }
            },
            skeleton: {
                enabled: true,
                color: 'white',
                lineWidth: 2,
                gradient: {
                    enabled: true,
                    speed: 0.5
                }
            },
            headDot: {
                enabled: true,
                color: 'cyan',
                size: 4
            },
            aimPoint: {
                enabled: false,
                style: 'cross', // 'dot', 'cross'
                color: 'rgba(255, 255, 0, 0.9)',
                size: 8,
                lineWidth: 1
            },
            tracers: {
                enabled: true,
                color: 'rgba(255, 255, 255, 0.2)',
                lineWidth: 1
            },
            fovCircle: {
                enabled: true,
                color: 'rgba(255,255,255,0.3)',
                lineWidth: 1,
                centerOnGameScreen: true,
                showOnlyWhenAiming: true,
                gradient: {
                    enabled: false,
                    speed: 0.5
                }
            },
            performanceMetrics: {
                enabled: true,
                position: 'top-left'
            },
            drawIgnoreRegion: {
                enabled: false,
                color: 'rgba(50, 50, 50, 0.4)',
                lineWidth: 1,
                showOnlyWhenAiming: true
            }
        }
    };

    // =================================================================================================
    // STATE
    // =================================================================================================
    const state = {
        gameVideo: null,
        detectionModel: null,
        modelLoaded: false,
        currentTarget: null,
        lastTargetSwitch: 0,
        frameCount: 0,
        lastDetectionTime: 0,
        rainbowHue: 0,
        performance: {
            fps: 0,
            framesThisSecond: 0,
            lastFpsUpdate: 0,
            detectionTime: 0,
            avgDetectionTime: 0,
            detectionTimeHistory: []
        },
        ui: {
            overlayCanvas: null,
            overlayCtx: null,
            offscreenCanvas: null,
            offscreenCtx: null
        },
        input: {
            lastMouseX: window.innerWidth / 2,
            lastMouseY: window.innerHeight / 2,
            leftButtonDown: false,
            rightButtonDown: false,
            shootingStartTime: 0,
            activeKeys: new Set()
        },
        isShooting: false,
        currentWeapon: 0,
        prediction: {
            networkLatency: 0,
            lastTargetId: null,
            targetHistory: {},
            lastPrediction: { x: 0, y: 0 },
            backend: 'unknown'
        }
    };

    // =================================================================================================
    // DEBUGGER
    // =================================================================================================
    const debug = {
        log: (...args) => console.log(`[Capybara AI Aimbot]`, ...args),
        warn: (...args) => console.warn(`[Capybara AI Aimbot]`, ...args),
        error: (...args) => console.error(`[Capybara AI Aimbot]`, ...args)
    };

    function showNotification(message, type = 'info', duration = 3000) {
        const n = document.createElement('div');
        n.style.cssText = `position:fixed;top:20px;left:50%;transform:translateX(-50%);padding:10px 20px;border-radius:5px;color:white;z-index:1000000;font-family:sans-serif;font-size:16px;box-shadow:0 2px 10px rgba(0,0,0,0.2);background-color:${
            type === 'error' ? 'rgba(255,0,0,0.8)' :
            type === 'warning' ? 'rgba(255,165,0,0.8)' :
            'rgba(0,0,0,0.7)'}`;
        n.textContent = message;
        document.body.appendChild(n);
        setTimeout(() => n.remove(), duration);
    }

    // =================================================================================================
    // PREDICTION SYSTEM
    // =================================================================================================
    function initializeTargetHistory(targetId) {
        if (!state.prediction.targetHistory[targetId]) {
            state.prediction.targetHistory[targetId] = {
                positions: [],
                timestamps: [],
                velocities: [],
                smoothedVelocity: { x: 0, y: 0 }
            };
        }
    }

    function updateTargetHistory(targetId, position, timestamp) {
        initializeTargetHistory(targetId);
        const history = state.prediction.targetHistory[targetId];

        history.positions.push({ x: position.x, y: position.y });
        history.timestamps.push(timestamp);

        if (history.positions.length > 1) {
            const prevPos = history.positions[history.positions.length - 2];
            const prevTime = history.timestamps[history.timestamps.length - 2];
            const dt = (timestamp - prevTime) / 1000;

            if (dt > 0) {
                const vx = (position.x - prevPos.x) / dt;
                const vy = (position.y - prevPos.y) / dt;

                const maxV = config.aim.prediction.maxVelocity;
                const limitedVx = Math.max(-maxV, Math.min(maxV, vx));
                const limitedVy = Math.max(-maxV, Math.min(maxV, vy));

                history.velocities.push({ x: limitedVx, y: limitedVy });

                const smoothing = config.aim.prediction.smoothingFactor;
                history.smoothedVelocity.x = history.smoothedVelocity.x * (1 - smoothing) + limitedVx * smoothing;
                history.smoothedVelocity.y = history.smoothedVelocity.y * (1 - smoothing) + limitedVy * smoothing;
            }
        }

        const bufferSize = config.aim.prediction.jitterBufferSize;
        if (history.positions.length > bufferSize) {
            history.positions.shift();
            history.timestamps.shift();
            if (history.velocities.length > 0) history.velocities.shift();
        }
    }

    function calculatePredictedPosition(targetId) {
        if (!state.prediction.targetHistory[targetId] ||
            state.prediction.targetHistory[targetId].positions.length < 2) {
            return null;
        }

        const history = state.prediction.targetHistory[targetId];
        const currentPos = history.positions[history.positions.length - 1];
        const currentTime = history.timestamps[history.timestamps.length - 1];

        const totalLatency = state.prediction.networkLatency +
                           state.performance.detectionTime +
                           config.aim.prediction.latencyCompensation;

        const vx = history.smoothedVelocity.x;
        const vy = history.smoothedVelocity.y;

        const scale = config.aim.prediction.predictionScale;

        const predictedX = currentPos.x + (vx * totalLatency / 1000) * scale;
        const predictedY = currentPos.y + (vy * totalLatency / 1000) * scale;

        return {
            x: predictedX,
            y: predictedY,
            velocityX: vx,
            velocityY: vy
        };
    }

    function updateTargetPrediction(newTarget) {
        const now = performance.now();

        if (!newTarget) {
            state.prediction.lastTargetId = null;
            return;
        }

        updateTargetHistory(newTarget.id, newTarget.screenPosition, now);
        state.prediction.lastTargetId = newTarget.id;
    }

    // =================================================================================================
    // BACKEND INITIALIZATION
    // =================================================================================================
    async function setupTensorFlow() {
        try {
            debug.log("Checking for an available TFJS backend then loading TFJS");

            const backends = [
                { name: 'webnn', test: () => typeof navigator.ml !== 'undefined' },
                { name: 'webgpu', test: () => typeof navigator.gpu !== 'undefined' },
                { name: 'webgl', test: () => true }
            ];

            let selectedBackend = null;

            for (const backend of backends) {
                if (backend.test()) {
                    try {
                        await tf.setBackend(backend.name);
                        await tf.ready();

                        if (backend.name === 'webgl') {
                            tf.env().set('WEBGL_VERSION', 2);
                            tf.env().set('WEBGL_CPU_FORWARD', false);
                            tf.env().set('WEBGL_PACK', true);
                            tf.env().set('WEBGL_FORCE_F16_TEXTURES', true);
                            tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);
                            tf.env().set('WEBGL_FLUSH_THRESHOLD', 1.75);
                        }

                        selectedBackend = backend.name;
                        state.prediction.backend = backend.name;
                        debug.log(`Successfully initialized ${backend.name.toUpperCase()} backend`);
                        break;
                    } catch (e) {
                        debug.warn(`Failed to initialize ${backend.name}:`, e.message);
                    }
                }
            }

            if (!selectedBackend) {
                throw new Error("Could not initialize any backend");
            }

            return true;
        } catch (e) {
            debug.error("TF setup failed:", e);
            showNotification("Failed to initialize AI backend", "error");
            return false;
        }
    }

    // =================================================================================================
    // MODEL LOADING
    // =================================================================================================
    async function loadDetectionModel() {
        debug.log("Loading the AI model");
        try {
            if (!await setupTensorFlow()) throw new Error("TF setup failed");
            if (typeof poseDetection === "undefined") throw new Error("Pose Detection API not loaded.");

            state.detectionModel = await poseDetection.createDetector(
                config.detection.modelType,
                config.detection.detectorConfig
            );

            const tC = document.createElement('canvas');
            tC.width = 192;
            tC.height = 192;
            await state.detectionModel.estimatePoses(tC);

            state.modelLoaded = true;
            debug.log("MoveNet model loaded!");
            showNotification(`AI model loaded (${state.prediction.backend.toUpperCase()})`, "info");
            return true;
        } catch (e) {
            debug.error("Failed to load AI model:", e);
            showNotification("Error loading AI model. Check console.", "error");
            return false;
        }
    }

    // =================================================================================================
    // TARGET DETECTION
    // =================================================================================================
    function calculateBoundingBoxFromKeypoints(kps) {
        if (!kps || kps.length === 0) return null;

        let mX = Infinity, mY = Infinity, mAX = -Infinity, mAY = -Infinity, vK = 0;
        kps.forEach(k => {
            if (k.score && k.score >= config.detection.keypointConfidence) {
                mX = Math.min(mX, k.x);
                mY = Math.min(mY, k.y);
                mAX = Math.max(mAX, k.x);
                mAY = Math.max(mAY, k.y);
                vK++;
            }
        });

        if (vK < 5) return null;

        const w = mAX - mX, h = mAY - mY, pX = 0.1 * w, pY = 0.1 * h;
        return {
            x: Math.max(0, mX - pX),
            y: Math.max(0, mY - pY),
            width: w + 2 * pX,
            height: h + 2 * pY,
            validKeypoints: vK
        };
    }

    function calculateAimTarget(pred, vRect) {
        if (!pred || !vRect || !state.gameVideo) return null;

        const [vBx, vBy, vBw, vBh] = pred.bbox || [0, 0, 0, 0];
        const sBx = vRect.left + vBx / state.gameVideo.videoWidth * vRect.width;
        const sBy = vRect.top + vBy / state.gameVideo.videoHeight * vRect.height;
        const sBw = vBw / state.gameVideo.videoWidth * vRect.width;
        const sBh = vBh / state.gameVideo.videoHeight * vRect.height;

        let tX = sBx + sBw / 2;
        let tY = sBy + sBh * (config.aim?.bodyOffset || 0.4);

        return {
            x: tX,
            y: tY,
            width: sBw,
            height: sBh,
            bboxRaw: pred.bbox
        };
    }

    function findBestTarget(predictions) {
        if (!predictions || !Array.isArray(predictions) || predictions.length === 0) return null;
        if (!state.gameVideo) return null;

        const videoRect = state.gameVideo.getBoundingClientRect();
        if (!videoRect || videoRect.width === 0) return null;

        const gameScreenCenterX = videoRect.left + videoRect.width / 2;
        const gameScreenCenterY = videoRect.top + videoRect.height / 2;
        let bestTarget = null;
        let bestScore = Infinity;

        predictions.forEach((prediction, index) => {
            const targetInfo = calculateAimTarget(prediction, videoRect);
            if (!targetInfo) return;

            let referenceX, referenceY;
            if (config.aim?.targetPriority === "center") {
                referenceX = gameScreenCenterX;
                referenceY = gameScreenCenterY;
            } else {
                referenceX = state.input.lastMouseX;
                referenceY = state.input.lastMouseY;
            }

            const dx = targetInfo.x - referenceX;
            const dy = targetInfo.y - referenceY;
            const distanceToPriorityPoint = Math.sqrt(dx * dx + dy * dy);

            // This is the crucial check: only consider targets within the FOV radius for aiming.
            if (distanceToPriorityPoint > (config.aim?.fovRadius || 200)) return;

            let score = distanceToPriorityPoint * (1.5 - (prediction.score || 0));

            if (score < bestScore) {
                bestScore = score;
                bestTarget = {
                    ...prediction, // Use the original prediction object
                    screenPosition: targetInfo,
                    distance: distanceToPriorityPoint,
                    id: index // Ensure each target has a unique ID for the frame
                };
            }
        });

        return bestTarget;
    }


    // =================================================================================================
    // INPUT CONTROLLER
    // =================================================================================================
    const InputController = {
        init: function() {
            state.input.lastMouseX = window.innerWidth / 2;
            state.input.lastMouseY = window.innerHeight / 2;

            document.addEventListener('mousemove', e => {
                state.input.lastMouseX = e.clientX;
                state.input.lastMouseY = e.clientY;
            });

            document.addEventListener('keydown', e => state.input.activeKeys.add(e.code));
            document.addEventListener('keyup', e => state.input.activeKeys.delete(e.code));

            document.addEventListener('mousedown', e => {
                if (e.button === 0) {
                    state.input.leftButtonDown = true;
                    state.input.shootingStartTime = performance.now();
                }
                if (e.button === 2) state.input.rightButtonDown = true;
            });

            document.addEventListener('mouseup', e => {
                if (e.button === 0) {
                    state.input.leftButtonDown = false;
                    state.input.shootingStartTime = 0;
                }
                if (e.button === 2) state.input.rightButtonDown = false;
            });

            debug.log("Input controller initialized");
            return true;
        },

        moveMouseTo: function(tSX, tSY) {
            if (!state.gameVideo) return;

            const vR = state.gameVideo.getBoundingClientRect();
            if (!vR || vR.width === 0) return;

            const gVCX = vR.left + vR.width / 2;
            const gVCY = vR.top + vR.height / 2;
            let mX = tSX - gVCX;
            let mY = tSY - gVCY;

            const sC = document.querySelector(config.game?.containerSelector) || state.gameVideo || document.documentElement;
            const evt = new PointerEvent('pointermove', {
                bubbles: true,
                cancelable: true,
                view: window,
                clientX: Math.round(state.input.lastMouseX + mX),
                clientY: Math.round(state.input.lastMouseY + mY),
                movementX: Math.round(mX),
                movementY: Math.round(mY),
                pointerType: 'mouse',
                isPrimary: true
            });
            sC.dispatchEvent(evt);
        },

        startShooting: function() {
            if (state.isShooting) return;

            const sC = document.querySelector(config.game?.containerSelector) || state.gameVideo || document.documentElement;
            const evt = new PointerEvent('pointerdown', {
                bubbles: true,
                cancelable: true,
                view: window,
                clientX: Math.round(state.input.lastMouseX),
                clientY: Math.round(state.input.lastMouseY),
                button: 0,
                buttons: 1,
                pointerType: 'mouse',
                isPrimary: true
            });
            sC.dispatchEvent(evt);
            state.isShooting = true;
        },

        stopShooting: function() {
            if (!state.isShooting) return;

            const sC = document.querySelector(config.game?.containerSelector) || state.gameVideo || document.documentElement;
            const evt = new PointerEvent('pointerup', {
                bubbles: true,
                cancelable: true,
                view: window,
                clientX: Math.round(state.input.lastMouseX),
                clientY: Math.round(state.input.lastMouseY),
                button: 0,
                pointerType: 'mouse',
                isPrimary: true
            });
            sC.dispatchEvent(evt);
            state.isShooting = false;
        }
    };

    // =================================================================================================
    // VISUAL OVERLAY
    // =================================================================================================
    function createOverlayCanvas() {
        if (state.ui.overlayCanvas) return;

        const c = document.createElement('canvas');
        c.id = 'xcloud-aimbot-overlay';
        c.width = window.innerWidth;
        c.height = window.innerHeight;
        c.style.cssText = 'position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:99999;';

        state.ui.overlayCanvas = c;
        state.ui.overlayCtx = c.getContext('2d');
        document.body.appendChild(c);

        window.addEventListener('resize', () => {
            c.width = window.innerWidth;
            c.height = window.innerHeight;
        });
    }

    function drawCrosshair(vR) {
        if (!state.ui.overlayCtx || !config.visual?.crosshair?.enabled) return;

        const ctx = state.ui.overlayCtx;
        let cX, cY;

        if (config.visual.crosshair?.centerOnGameScreen && vR && vR.width > 0) {
            cX = vR.left + vR.width / 2;
            cY = vR.top + vR.height / 2;
        } else {
            cX = state.input.lastMouseX;
            cY = state.input.lastMouseY;
        }

        const s = config.visual.crosshair?.size || 3;
        const color = config.visual.crosshair?.color || 'lime';

        ctx.strokeStyle = color;
        ctx.fillStyle = color;
        ctx.lineWidth = 1;

        switch (config.visual.crosshair?.style || 'dot') {
            case 'cross':
                ctx.beginPath();
                ctx.moveTo(cX - 2 * s, cY);
                ctx.lineTo(cX + 2 * s, cY);
                ctx.moveTo(cX, cY - 2 * s);
                ctx.lineTo(cX, cY + 2 * s);
                ctx.stroke();
                break;
            case 'dot':
                ctx.beginPath();
                ctx.arc(cX, cY, s, 0, 2 * Math.PI);
                ctx.fill();
                break;
            case 'circle':
                ctx.beginPath();
                ctx.arc(cX, cY, 2 * s, 0, 2 * Math.PI);
                ctx.stroke();
                break;
        }
    }

    function drawTargetLockIndicator(t, vR) {
        if (!config.visual?.targetLock?.enabled || !state.ui.overlayCtx || !t || !vR || !state.gameVideo) return;

        const ctx = state.ui.overlayCtx;
        const cfg = config.visual.targetLock;
        const bbox = t.bbox || [0, 0, 0, 0];
        const [vBx, vBy, vBw, vBh] = bbox;
        const bSX = vR.left + vBx / state.gameVideo.videoWidth * vR.width;
        const bSY = vR.top + vBy / state.gameVideo.videoHeight * vR.height;
        const bSW = vBw / state.gameVideo.videoWidth * vR.width;
        const bSH = vBh / state.gameVideo.videoHeight * vR.height;

        if (cfg.fillEnabled) {
            ctx.fillStyle = cfg.fillColor || 'rgba(255, 0, 0, 0.1)';
            ctx.fillRect(bSX, bSY, bSW, bSH);
        }

        ctx.strokeStyle = cfg.gradient.enabled ? `hsl(${state.rainbowHue}, 100%, 50%)` : (cfg.color || 'red');
        ctx.lineWidth = cfg.lineWidth || 2;

        const cS = 0.2 * Math.min(bSW, bSH);
        switch (cfg.style || 'full') {
            case 'full':
                ctx.strokeRect(bSX, bSY, bSW, bSH);
                break;
            case 'corners':
                ctx.beginPath();
                ctx.moveTo(bSX + cS, bSY);
                ctx.lineTo(bSX, bSY);
                ctx.lineTo(bSX, bSY + cS);
                ctx.moveTo(bSX + bSW - cS, bSY);
                ctx.lineTo(bSX + bSW, bSY);
                ctx.lineTo(bSX + bSW, bSY + cS);
                ctx.moveTo(bSX + cS, bSY + bSH);
                ctx.lineTo(bSX, bSY + bSH);
                ctx.lineTo(bSX, bSY + bSH - cS);
                ctx.moveTo(bSX + bSW - cS, bSY + bSH);
                ctx.lineTo(bSX + bSW, bSY + bSH);
                ctx.lineTo(bSX + bSW, bSY + bSH - cS);
                ctx.stroke();
                break;
        }
    }

    function drawSkeleton(t, vR) {
        if (!config.visual?.skeleton?.enabled || !state.ui.overlayCtx || !t || !vR || !state.gameVideo) return;

        const ctx = state.ui.overlayCtx;
        const cfg = config.visual.skeleton;
        const keypoints = t.keypoints;
        if (!keypoints) return;

        ctx.strokeStyle = cfg.gradient.enabled ? `hsl(${state.rainbowHue}, 100%, 50%)` : (cfg.color || 'white');
        ctx.lineWidth = cfg.lineWidth || 2;

        const connections = [
            ['left_shoulder', 'right_shoulder'], ['left_shoulder', 'left_hip'], ['right_shoulder', 'right_hip'], ['left_hip', 'right_hip'],
            ['left_shoulder', 'left_elbow'], ['left_elbow', 'left_wrist'], ['right_shoulder', 'right_elbow'], ['right_elbow', 'right_wrist'],
            ['left_hip', 'left_knee'], ['left_knee', 'left_ankle'], ['right_hip', 'right_knee'], ['right_knee', 'right_ankle']
        ];

        const keypointsMap = new Map(keypoints.map(kp => [kp.name, kp]));

        connections.forEach(conn => {
            const [start, end] = conn;
            const kp1 = keypointsMap.get(start);
            const kp2 = keypointsMap.get(end);

            if (kp1 && kp2 && kp1.score > config.detection.keypointConfidence && kp2.score > config.detection.keypointConfidence) {
                const x1 = vR.left + kp1.x / state.gameVideo.videoWidth * vR.width;
                const y1 = vR.top + kp1.y / state.gameVideo.videoHeight * vR.height;
                const x2 = vR.left + kp2.x / state.gameVideo.videoWidth * vR.width;
                const y2 = vR.top + kp2.y / state.gameVideo.videoHeight * vR.height;

                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
        });
    }

    function drawHeadDot(t, vR) {
        if (!config.visual?.headDot?.enabled || !state.ui.overlayCtx || !t || !vR || !state.gameVideo) return;
        const ctx = state.ui.overlayCtx;
        const cfg = config.visual.headDot;
        const keypoints = t.keypoints;
        if (!keypoints) return;

        const nose = keypoints.find(kp => kp.name === 'nose');
        if (nose && nose.score > config.detection.keypointConfidence) {
            const x = vR.left + nose.x / state.gameVideo.videoWidth * vR.width;
            const y = vR.top + nose.y / state.gameVideo.videoHeight * vR.height;

            ctx.fillStyle = cfg.color || 'cyan';
            ctx.beginPath();
            ctx.arc(x, y, cfg.size || 4, 0, 2 * Math.PI);
            ctx.fill();
        }
    }

    function drawAimPoint(aimPosition) {
        if (!config.visual?.aimPoint?.enabled || !state.ui.overlayCtx || !aimPosition) return;
        const ctx = state.ui.overlayCtx;
        const cfg = config.visual.aimPoint;
        const { x, y } = aimPosition;

        ctx.strokeStyle = cfg.color || 'yellow';
        ctx.fillStyle = cfg.color || 'yellow';
        ctx.lineWidth = cfg.lineWidth || 1;
        const size = cfg.size || 8;

        switch (cfg.style || 'cross') {
            case 'cross':
                ctx.beginPath();
                ctx.moveTo(x - size / 2, y);
                ctx.lineTo(x + size / 2, y);
                ctx.moveTo(x, y - size / 2);
                ctx.lineTo(x, y + size / 2);
                ctx.stroke();
                break;
            case 'dot':
                ctx.beginPath();
                ctx.arc(x, y, size / 2, 0, 2 * Math.PI);
                ctx.fill();
                break;
        }
    }

    function drawTracer(aimPosition, vR) {
        if (!config.visual?.tracers?.enabled || !state.ui.overlayCtx || !aimPosition || !vR) return;
        const ctx = state.ui.overlayCtx;
        const cfg = config.visual.tracers;

        const startX = vR.left + vR.width / 2;
        const startY = vR.top + vR.height / 2;
        const { x: endX, y: endY } = aimPosition;

        ctx.strokeStyle = cfg.color || 'rgba(255, 255, 255, 0.2)';
        ctx.lineWidth = cfg.lineWidth || 1;

        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.stroke();
    }


    function drawFOVCircle(vR) {
        if (!config.visual?.fovCircle?.enabled || !state.ui.overlayCtx) return;
        if (config.visual.fovCircle?.showOnlyWhenAiming && !state.input.activeKeys.has(config.aim?.activationKey || 'KeyQ')) return;

        const ctx = state.ui.overlayCtx;
        let cX, cY;

        if (config.visual.fovCircle?.centerOnGameScreen && vR && vR.width > 0) {
            cX = vR.left + vR.width / 2;
            cY = vR.top + vR.height / 2;
        } else {
            cX = state.input.lastMouseX;
            cY = state.input.lastMouseY;
        }

        ctx.strokeStyle = config.visual.fovCircle.gradient.enabled ?
            `hsl(${state.rainbowHue}, 100%, 50%)` :
            (config.visual.fovCircle?.color || 'rgba(255,255,255,0.3)');
        ctx.lineWidth = config.visual.fovCircle?.lineWidth || 1;
        ctx.beginPath();
        const radius = config.aim.smartSlowdown.enabled ?
            Math.max(config.aim.fovRadius, config.aim.smartSlowdown.slowdownRadius) :
            config.aim.fovRadius;
        ctx.arc(cX, cY, radius || 200, 0, 2 * Math.PI);
        ctx.stroke();
    }

    function drawDebugInfo() {
        if (!config.visual?.showDebugInfo || !state.ui.overlayCtx) return;

        const ctx = state.ui.overlayCtx;
        ctx.font = '12px Arial';
        ctx.fillStyle = 'rgba(255,255,0,0.8)';
        ctx.fillText(`Backend: ${state.prediction.backend.toUpperCase()}`, 10, 80);
        ctx.fillText(`Mouse: X:${state.input.lastMouseX.toFixed(0)} Y:${state.input.lastMouseY.toFixed(0)}`, 10, 96);
    }

    function drawPerformanceMetrics() {
        if (!config.visual?.performanceMetrics?.enabled || !state.ui.overlayCtx) return;

        const ctx = state.ui.overlayCtx;
        ctx.font = '14px Arial';
        ctx.fillStyle = 'rgba(0,255,0,0.8)';
        ctx.fillText(`FPS: ${state.performance.fps}`, 10, 20);
        ctx.fillText(`Detect: ${state.performance.detectionTime.toFixed(1)}ms (Avg: ${state.performance.avgDetectionTime.toFixed(1)}ms)`, 10, 36);
        ctx.fillStyle = 'rgba(255, 165, 0, 0.9)';
        ctx.fillText(`Net Latency: ${state.prediction.networkLatency.toFixed(1)}ms`, 10, 52);

        if (state.currentTarget && state.prediction.targetHistory[state.currentTarget.id]) {
            const history = state.prediction.targetHistory[state.currentTarget.id];
            ctx.fillText(`Target Vel: X:${(history.smoothedVelocity.x || 0).toFixed(2)} Y:${(history.smoothedVelocity.y || 0).toFixed(2)}`, 10, 68);
        }
    }

    function drawIgnoreSelfRegionVisualization(videoRect) {
        if (!config.detection?.ignoreSelfRegion?.enabled ||
            !config.visual?.drawIgnoreRegion?.enabled ||
            !state.ui.overlayCtx || !videoRect || videoRect.width === 0) return;

        const ctx = state.ui.overlayCtx;
        const region = config.detection.ignoreSelfRegion || {};
        const visConfig = config.visual.drawIgnoreRegion || {};

        const rectX = videoRect.left + videoRect.width * (region.xPercent || 0);
        const rectY = videoRect.top + videoRect.height * (region.yPercent || 0);
        const rectW = videoRect.width * (region.widthPercent || 0);
        const rectH = videoRect.height * (region.heightPercent || 0);

        ctx.fillStyle = visConfig.color || 'rgba(50, 50, 50, 0.4)';
        ctx.fillRect(rectX, rectY, rectW, rectH);
    }

    function drawVisuals(playersToDraw, currentTarget, aimPosition) {
        if (!state.ui.overlayCtx) return;

        const ctx = state.ui.overlayCtx;
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

        const videoRect = state.gameVideo ? state.gameVideo.getBoundingClientRect() : null;
        const isAimKeyHeld = state.input.activeKeys.has(config.aim?.activationKey || 'KeyQ');

        drawCrosshair(videoRect);

        if (isAimKeyHeld) {
            drawFOVCircle(videoRect);

            if (config.detection?.ignoreSelfRegion?.enabled && config.visual?.drawIgnoreRegion?.enabled && videoRect) {
                drawIgnoreSelfRegionVisualization(videoRect);
            }

            if (videoRect && videoRect.width > 0 && playersToDraw) {
                playersToDraw.forEach(player => {
                    drawTargetLockIndicator(player, videoRect);
                    drawSkeleton(player, videoRect);
                    drawHeadDot(player, videoRect);
                });
            }

            // Draw visuals specific to the locked target
            if (currentTarget && aimPosition) {
                drawTracer(aimPosition, videoRect);
                drawAimPoint(aimPosition);
            }
        }

        if (config.visual?.performanceMetrics?.enabled) drawPerformanceMetrics();
        if (config.visual?.showDebugInfo) drawDebugInfo();
    }


    // =================================================================================================
    // DETECTION CORE
    // =================================================================================================
    async function detectPlayers() {
        if (!state.input.activeKeys.has(config.aim?.activationKey || 'KeyQ')) {
            return [];
        }

        if (!state.gameVideo || !state.modelLoaded || !state.detectionModel ||
            state.gameVideo.paused || state.gameVideo.ended || state.gameVideo.videoWidth === 0) {
            return [];
        }

        if (state.frameCount++ % ((config.detection?.skipFrames || 0) + 1) !== 0) {
            return [];
        }

        const now = performance.now();
        if (now - state.lastDetectionTime < (config.detection?.processingInterval || 0)) {
            return [];
        }

        let videoSource = state.gameVideo;

        if (config.detection?.ignoreSelfRegion?.enabled) {
            if (!state.ui.offscreenCanvas) {
                state.ui.offscreenCanvas = document.createElement('canvas');
                state.ui.offscreenCtx = state.ui.offscreenCanvas.getContext('2d');
            }

            if (state.ui.offscreenCanvas.width !== state.gameVideo.videoWidth ||
                state.ui.offscreenCanvas.height !== state.gameVideo.videoHeight) {
                state.ui.offscreenCanvas.width = state.gameVideo.videoWidth;
                state.ui.offscreenCanvas.height = state.gameVideo.videoHeight;
            }

            const ctx = state.ui.offscreenCtx;
            ctx.drawImage(state.gameVideo, 0, 0, state.gameVideo.videoWidth, state.gameVideo.videoHeight);

            const region = config.detection.ignoreSelfRegion || {};
            ctx.fillStyle = 'rgba(0, 0, 0, 1)';
            ctx.fillRect(
                state.gameVideo.videoWidth * (region.xPercent || 0),
                state.gameVideo.videoHeight * (region.yPercent || 0),
                state.gameVideo.videoWidth * (region.widthPercent || 0),
                state.gameVideo.videoHeight * (region.heightPercent || 0)
            );

            videoSource = state.ui.offscreenCanvas;
        }

        try {
            const detectionStart = performance.now();
            const poses = await state.detectionModel.estimatePoses(videoSource, { flipHorizontal: false });

            state.performance.detectionTime = performance.now() - detectionStart;
            state.performance.detectionTimeHistory.push(state.performance.detectionTime);

            if (state.performance.detectionTimeHistory.length > 30) {
                state.performance.detectionTimeHistory.shift();
            }

            state.performance.avgDetectionTime = state.performance.detectionTimeHistory.reduce((a, b) => a + b, 0) /
                                              state.performance.detectionTimeHistory.length;
            state.lastDetectionTime = now;

            const results = [];
            if (poses && poses.length > 0) {
                for (const pose of poses) {
                    if (pose.score && pose.score >= (config.detection?.detectorConfig?.minPoseScore || 0)) {
                        const bbox = calculateBoundingBoxFromKeypoints(pose.keypoints);
                        if (bbox && bbox.width > 0 && bbox.height > 0) {
                            results.push({
                                class: 'person',
                                score: pose.score,
                                bbox: [bbox.x, bbox.y, bbox.width, bbox.height],
                                keypoints: pose.keypoints
                            });
                        }
                    }
                }
            }

            return results.slice(0, config.detection?.maxDetections || 1);
        } catch (err) {
            debug.error("Error during pose estimation:", err);
            return [];
        }
    }

    // =================================================================================================
    // AIMING LOGIC
    // =================================================================================================
    function calculateFinalAimPosition(targetX, targetY) {
        if (config.aim?.aimSpeed?.enabled) {
            const videoRect = state.gameVideo?.getBoundingClientRect();
            if (videoRect && videoRect.width > 0) {
                const referenceX = videoRect.left + videoRect.width / 2;
                const referenceY = videoRect.top + videoRect.height / 2;
                let speedDecimal = 1.0;

                if (config.aim.smartSlowdown.enabled) {
                    const slowdownCfg = config.aim.smartSlowdown;
                    const dist = Math.hypot(targetX - referenceX, targetY - referenceY);
                    let effectiveRadius = slowdownCfg.slowdownRadius;

                    if (slowdownCfg.prediction.enabled && state.currentTarget && state.currentTarget.id !== null) {
                        const history = state.prediction.targetHistory[state.currentTarget.id];
                        if (history && history.smoothedVelocity) {
                            const totalLatency = state.prediction.networkLatency + state.performance.avgDetectionTime;
                            const targetSpeed = Math.hypot(history.smoothedVelocity.x, history.smoothedVelocity.y);
                            const predictionDistance = (targetSpeed * totalLatency) / 1000;
                            effectiveRadius += predictionDistance;
                        }
                    }

                    if (dist < effectiveRadius) {
                        let slowdownFactor = Math.min(1.0, dist / effectiveRadius);

                        if (slowdownCfg.nonlinear && slowdownCfg.nonlinear.enabled) {
                            slowdownFactor = Math.pow(slowdownFactor, slowdownCfg.nonlinear.exponent || 2.0);
                        }

                        const speedRange = slowdownCfg.maxSpeed - slowdownCfg.minSpeed;
                        const dynamicSpeed = slowdownCfg.minSpeed + (speedRange * slowdownFactor);
                        speedDecimal = dynamicSpeed / 100.0;

                    } else {
                        speedDecimal = slowdownCfg.maxSpeed / 100.0;
                    }
                } else {
                    speedDecimal = (config.aim.aimSpeed.speedPercent || 85) / 100.0;
                }

                return {
                    x: referenceX + (targetX - referenceX) * speedDecimal,
                    y: referenceY + (targetY - referenceY) * speedDecimal
                };
            }
        }
        return { x: targetX, y: targetY };
    }


    async function processAiming(timestamp) {
        const isAimKeyHeld = state.input.activeKeys.has(config.aim?.activationKey || 'KeyQ');
        const now = performance.now();

        if (!isAimKeyHeld || !config.detection?.enabled || !state.modelLoaded) {
            state.currentTarget = null;
            if (state.isShooting) InputController.stopShooting();
            drawVisuals([], null, null); // Clear visuals
            return;
        }

        const allDetectedPlayers = await detectPlayers();
        const newTarget = findBestTarget(allDetectedPlayers);

        updateTargetPrediction(newTarget);

        if (newTarget) {
            if (!state.currentTarget || newTarget.id !== state.currentTarget.id) {
                if (!state.currentTarget || now - state.lastTargetSwitch > (config.aim?.targetSwitchCooldown || 0)) {
                    state.currentTarget = newTarget;
                    state.lastTargetSwitch = now;
                }
            } else {
                state.currentTarget = newTarget;
            }
        } else {
            state.currentTarget = null;
        }

        let aimPosition = null;
        if (state.currentTarget) {
            let { x: targetX, y: targetY } = state.currentTarget.screenPosition || { x: 0, y: 0 };

            if (config.aim.prediction.enabled) {
                const predictedPos = calculatePredictedPosition(state.currentTarget.id);
                if (predictedPos) {
                    targetX = predictedPos.x;
                    targetY = predictedPos.y;
                }
            }

            const finalAim = calculateFinalAimPosition(targetX, targetY);
            aimPosition = { x: finalAim.x, y: finalAim.y };

            InputController.moveMouseTo(finalAim.x, finalAim.y);

            if (config.game?.autoShoot && state.currentTarget.distance < (config.aim?.fovRadius || 200) * (config.aim?.triggerThreshold || 0.7)) {
                if (!state.isShooting) {
                    setTimeout(() => {
                        if (state.currentTarget && state.input.activeKeys.has(config.aim?.activationKey || 'KeyQ')) {
                            InputController.startShooting();
                        }
                    }, config.game?.triggerOptions?.delayBeforeShoot || 0);
                }
            } else if (state.isShooting) {
                InputController.stopShooting();
            }
        } else {
            if (state.isShooting) InputController.stopShooting();
        }

        // Determine which players to draw based on the "Better Detection" setting
        const playersToDraw = config.detection.betterDetection.enabled ? allDetectedPlayers : (state.currentTarget ? [state.currentTarget] : []);
        drawVisuals(playersToDraw, state.currentTarget, aimPosition);
    }


    // =================================================================================================
    // MAIN LOOP
    // =================================================================================================
    function startAimbotLoop() {
        async function mainLoop(timestamp) {
            requestAnimationFrame(mainLoop);

            state.performance.framesThisSecond++;
            if (timestamp - state.performance.lastFpsUpdate >= 1000) {
                state.performance.fps = state.performance.framesThisSecond;
                state.performance.framesThisSecond = 0;
                state.performance.lastFpsUpdate = timestamp;
            }

            const gradientSpeed = Math.max(
                config.visual.targetLock.gradient.speed,
                config.visual.skeleton.gradient.speed,
                config.visual.fovCircle.gradient.speed
            );
            if (gradientSpeed > 0) {
                state.rainbowHue = (timestamp * gradientSpeed * 0.1) % 360;
            }


            if (!state.gameVideo || state.gameVideo.paused || state.gameVideo.ended || state.gameVideo.videoWidth === 0) {
                if (state.isShooting) InputController.stopShooting();
                if (state.ui.overlayCtx) state.ui.overlayCtx.clearRect(0, 0, state.ui.overlayCanvas.width, state.ui.overlayCanvas.height);
                state.currentTarget = null;
                return;
            }

            await processAiming(timestamp);
        }

        requestAnimationFrame(mainLoop);
    }

    // =================================================================================================
    // INITIALIZATION
    // =================================================================================================
    async function initializeAimbot() {
        debug.log(`Initializing Capybara AI Aimbot...`);

        state.gameVideo = document.querySelector(config.game?.videoSelector || 'video');
        if (!state.gameVideo) {
            debug.error("Game video element not found. Retrying...");
            setTimeout(initializeAimbot, 3000);
            return;
        }

        createOverlayCanvas();

        const workerBlob = new Blob(['// Dummy Worker'], { type: 'application/javascript' });
        const workerUrl = URL.createObjectURL(workerBlob);
        new Worker(workerUrl);

        const observer = new PerformanceObserver((list) => {
            const lastEntry = list.getEntries().pop();
            if (lastEntry && lastEntry.name.includes('.svg')) {
                state.prediction.networkLatency = lastEntry.duration;
            }
        });
        observer.observe({ type: "resource", buffered: true });

        InputController.init();

        if (config.detection?.enabled) {
            await loadDetectionModel();
        }

        startAimbotLoop();
        debug.log("Initialization complete. Capybara AI Aimbot is now active.");
        showNotification(`Capybara AI Aimbot Loaded (${state.prediction.backend.toUpperCase()})`, "info");
    }

    if (document.readyState === 'complete' || document.readyState === 'interactive') {
        setTimeout(initializeAimbot, 25);
    } else {
        window.addEventListener('load', () => setTimeout(initializeAimbot, 25));
    }
})();
