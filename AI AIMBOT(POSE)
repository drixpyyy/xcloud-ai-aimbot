// ==UserScript==
// @name         dont really wanna work on this but im adding some stuff for it to work
// @description  AI-powered aimbot for Fortnite on xCloud compatible with chromeOS and Windows and Linux(future updates soon)
// @author       wesd
// @version      5.2.0
// @match        *://*.xbox.com/play/*
// @grant        none
// @run-at       document-end
// @require      https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core@3.18.0/dist/tf-core.min.js
// @require      https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter@3.18.0/dist/tf-converter.min.js
// @require      https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@3.18.0/dist/tf-backend-webgl.min.js
// @require      https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.0.0/dist/pose-detection.min.js
// ==/UserScript==

(function() {
    'use strict';

    // === Configuration Section ===
    const config = {
        // Detection settings for MoveNet AI model
        detection: {
            enabled: true,
            modelType: poseDetection.SupportedModels.MoveNet,
            detectorConfig: {
                modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING,
                enableSmoothing: true,
                minPoseScore: 0.15
            },
            keypointConfidence: 0.20,
            maxDetections: 3,
            processingInterval: 0,
            skipFrames: 0,
            dynamicFrameSkipping: {
                enabled: true,
                minSkipFrames: 0,
                maxSkipFrames: 2,
                targetFPS: 58,
                highDetectionTimeThreshold: 15,
                lowDetectionTimeThreshold: 8,
                fpsThresholdLow: 50,
                fpsThresholdHigh: 59
            },
            useWebGL2: true,
            useOffscreenCanvas: typeof OffscreenCanvas !== 'undefined',
            ignoreSelfRegion: {
                enabled: false,
                xPercent: 0.00,
                yPercent: 0.27,
                widthPercent: 0.37,
                heightPercent: 0.74
            }
        },
        // Game interaction settings
        game: {
            videoSelector: 'video[aria-label="Game Stream for unknown title"]',
            containerSelector: '#game-stream',
            autoShoot: false,
            triggerOptions: {
                burstMode: false,
                burstCount: 1,
                burstInterval: 100
            },
            controlOptions: {
                crouchOnShoot: false,
                crouchKey: 'KeyC',
                reloadKey: 'KeyR',
                weaponKeys: ['Digit1', 'Digit2', 'Digit3', 'Digit4', 'Digit5']
            }
        },
        // Aiming settings
        aim: {
            activationKey: 'KeyE',
            fovRadius: 300,
            instantLock: false,
            aimPoint: "torso_center",
            headOffset: 0.15,
            bodyOffset: 0.4,
            targetPriority: "center",
            targetSwitchCooldown: 10,
            triggerThreshold: 0.7,

            // --- CUSTOM AIM SETTINGS (Your "one step at a time" logic) ---
            // These values determine how the mouse moves towards the target.
            // Tune these for feel and responsiveness.
            normalMovementSpeed: 0.1, // Fraction of distance to move towards target normally (0.01 to 0.5)
                                       // A higher value makes it move faster.
            slowdownThresholdPixels: 50, // Distance in pixels from the target's center to start slowing down.
                                         // When mouse is within this distance, slowdownSpeedFraction is used.
            slowdownMovementSpeed: 0.02 // Fraction of distance to move when in slowdownThresholdPixels.
                                        // A lower value makes it slow down more significantly.
        },
        // Visual overlay settings
        visual: {
            showDebugInfo: true,
            crosshair: {
                enabled: true,
                style: 'dot',
                color: 'lime',
                size: 3,
                centerOnGameScreen: true
            },
            targetDot: { // Blue dot at calculated aim point
                enabled: true,
                color: 'blue',
                radius: 4
            },
            boundingBoxes: { enabled: true, color: 'rgba(255,0,0,0.5)', lineWidth: 1, showInfo: false, fromKeypoints: false },
            keypoints: {
                enabled: false,
                color: 'cyan',
                radius: 3
            },
            skeleton: {
                enabled: false,
                color: 'rgba(255, 0, 255, 0.9)',
                lineWidth: 2
            },
            targetLock: {
                enabled: true,
                color: 'yellow',
                style: 'corners'
            },
            fovCircle: {
                enabled: true,
                color: 'rgba(255,255,255,0.3)',
                lineWidth: 1,
                centerOnGameScreen: true,
                showOnlyWhenAiming: true
            },
            performanceMetrics: {
                enabled: true,
                position: 'top-left'
            },
            showRecoilTunerGUI: false
        }
    };
    config.version = '5.2.0';

    // === Debugging and State Management ===
    const tfState = {
        backend: 'webgl',
        flags: { WEBGL_VERSION: 2, WEBGL_RENDER_FLOAT32_ENABLED: true }
    };

    const state = {
        gameVideo: null,
        detectionModel: null,
        modelLoaded: false,
        currentTarget: null,
        lastTargetSwitch: 0,
        frameCount: 0,
        lastDetectionTime: 0,
        performance: {
            fps: 0,
            framesThisSecond: 0,
            lastFpsUpdate: 0,
            detectionTime: 0,
            avgDetectionTime: 0,
            detectionTimeHistory: []
        },
        ui: {
            overlayCanvas: null,
            overlayCtx: null,
            offscreenCanvas: null, // Used for OffscreenCanvas
            offscreenCtx: null,    // Used for OffscreenCanvas
        },
        input: {
            lastMouseX: window.innerWidth / 2,
            lastMouseY: window.innerHeight / 2,
            leftButtonDown: false,
            rightButtonDown: false,
            activeKeys: new Set(),
            // Removed lastAimErrorX/Y as PD controller is removed
        },
        isShooting: false,
        currentWeapon: 0,
        lastFrameTime: performance.now() // Used for delta time, but now less critical for PD controller
    };

    const debug = {
        log: (...args) => console.log(`[AimbotV${config.version}-MoveNet]`, ...args),
        warn: (...args) => console.warn(`[AimbotV${config.version}-MoveNet]`, ...args),
        error: (...args) => console.error(`[AimbotV${config.version}-MoveNet]`, ...args)
    };

    // === Utility Functions ===
    function showNotification(message, type = 'info', duration = 3000) {
        const n = document.createElement('div');
        n.style.cssText = `position:fixed;top:20px;left:50%;transform:translateX(-50%);padding:10px 20px;border-radius:5px;color:white;z-index:1000000;font-family:sans-serif;font-size:16px;box-shadow:0 2px 10px rgba(0,0,0,0.2);background-color:${type === 'error' ? 'rgba(255,0,0,0.8)' : type === 'warning' ? 'rgba(255,165,0,0.8)' : 'rgba(0,0,0,0.7)'};`;
        n.textContent = message;
        document.body.appendChild(n);
        setTimeout(() => n.remove(), duration);
    }

    async function setupTensorFlow() {
        try {
            debug.log("Configuring TF.js...");
            await tf.setBackend(tfState.backend);
            await tf.ready();
            for (const f in tfState.flags) tf.env().set(f, tfState.flags[f]);
            debug.log(`TF.js backend: ${tf.getBackend()}`);
            if (tf.getBackend() === 'webgl') debug.log(`WebGL Version: ${tf.env().get('WEBGL_VERSION')}`);
            const sT = performance.now();
            const tT = tf.zeros([100, 100, 3]);
            await tT.data();
            tT.dispose();
            debug.log(`TF basic op test: ${(performance.now() - sT).toFixed(2)}ms`);
            return true;
        } catch (e) {
            debug.error("TF setup failed:", e);
            return false;
        }
    }

    async function loadDetectionModel() {
        debug.log("Loading MoveNet model...");
        try {
            if (!await setupTensorFlow()) throw Error("TF setup failed");
            if (typeof poseDetection === "undefined") throw Error("Pose Detection API not loaded.");
            state.detectionModel = await poseDetection.createDetector(config.detection.modelType, config.detection.detectorConfig);
            const tC = document.createElement('canvas');
            tC.width = 192;
            tC.height = 192;
            await state.detectionModel.estimatePoses(tC);
            state.modelLoaded = true;
            debug.log("MoveNet model loaded!");
            showNotification("AI Model (MoveNet) Loaded!", "info");
            return true;
        } catch (e) {
            debug.error("Failed to load MoveNet model:", e);
            showNotification("Error loading AI model (MoveNet)! Check console.", "error");
            return false;
        }
    }

    // === Detection and Targeting Functions ===
    function calculateBoundingBoxFromKeypoints(kps) {
        if (!kps || kps.length === 0) return null;
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity, validKeypointsCount = 0;
        kps.forEach(k => {
            if (k.score && k.score >= config.detection.keypointConfidence) {
                minX = Math.min(minX, k.x);
                minY = Math.min(minY, k.y);
                maxX = Math.max(maxX, k.x);
                maxY = Math.max(maxY, k.y);
                validKeypointsCount++;
            }
        });
        if (validKeypointsCount < 5) return null;
        const width = maxX - minX, height = maxY - minY, paddingX = 0.1 * width, paddingY = 0.1 * height;
        return { x: Math.max(0, minX - paddingX), y: Math.max(0, minY - paddingY), width: maxX - minX + 2 * paddingX, height: maxY - minY + 2 * paddingY, validKeypoints: validKeypointsCount };
    }

    function calculateAimTarget(prediction, videoRect) {
        const [rawX, rawY, rawWidth, rawHeight] = prediction.bbox;

        const screenX = videoRect.left + rawX / state.gameVideo.videoWidth * videoRect.width;
        const screenY = videoRect.top + rawY / state.gameVideo.videoHeight * videoRect.height;
        const screenWidth = rawWidth / state.gameVideo.videoWidth * videoRect.width;
        const screenHeight = rawHeight / state.gameVideo.videoHeight * videoRect.height;

        let targetX, targetY;
        const keypoints = prediction.keypoints;
        const getKeypoint = name => keypoints.find(k => k.name === name && k.score >= config.detection.keypointConfidence);

        switch (config.aim.aimPoint) {
            case "head":
                const nose = getKeypoint('nose'), leftEye = getKeypoint('left_eye'), rightEye = getKeypoint('right_eye');
                if (nose) {
                    targetX = videoRect.left + nose.x / state.gameVideo.videoWidth * videoRect.width;
                    targetY = videoRect.top + nose.y / state.gameVideo.videoHeight * videoRect.height;
                } else if (leftEye && rightEye) {
                    targetX = videoRect.left + ((leftEye.x + rightEye.x) / 2) / state.gameVideo.videoWidth * videoRect.width;
                    targetY = videoRect.top + ((leftEye.y + rightEye.y) / 2) / state.gameVideo.videoHeight * videoRect.height;
                } else {
                    targetX = screenX + screenWidth / 2;
                    targetY = screenY + screenHeight * config.aim.headOffset;
                }
                break;
            case "neck":
                const leftShoulder_neck = getKeypoint('left_shoulder'), rightShoulder_neck = getKeypoint('right_shoulder');
                if (leftShoulder_neck && rightShoulder_neck) {
                    targetX = videoRect.left + ((leftShoulder_neck.x + rightShoulder_neck.x) / 2) / state.gameVideo.videoWidth * videoRect.width;
                    targetY = videoRect.top + ((leftShoulder_neck.y + rightShoulder_neck.y) / 2 - screenHeight * 0.05) / state.gameVideo.videoHeight * videoRect.height;
                } else {
                    targetX = screenX + screenWidth / 2;
                    targetY = screenY + screenHeight * (config.aim.headOffset + 0.1);
                }
                break;
            case "torso_center":
                const leftShoulder_torso = getKeypoint('left_shoulder'), rightShoulder_torso = getKeypoint('right_shoulder');
                const leftHip_torso = getKeypoint('left_hip'), rightHip_torso = getKeypoint('right_hip');
                if (leftShoulder_torso && rightShoulder_torso && leftHip_torso && rightHip_torso) {
                    targetX = videoRect.left + (((leftShoulder_torso.x + rightShoulder_torso.x) / 2 + (leftHip_torso.x + rightHip_torso.x) / 2) / 2) / state.gameVideo.videoWidth * videoRect.width;
                    targetY = videoRect.top + (((leftShoulder_torso.y + rightShoulder_torso.y) / 2 + (leftHip_torso.y + rightHip_torso.y) / 2) / 2) / state.gameVideo.videoHeight * videoRect.height;
                } else {
                    targetX = screenX + screenWidth / 2;
                    targetY = screenY + screenHeight * config.aim.bodyOffset;
                }
                break;
            case "center":
            default:
                targetX = screenX + screenWidth / 2;
                targetY = screenY + screenHeight / 2;
                break;
        }
        return { x: targetX, y: targetY, width: screenWidth, height: screenHeight, bboxRaw: prediction.bbox, keypoints: prediction.keypoints };
    }

    function findBestTarget(predictions, videoRect) {
        if (!predictions || predictions.length === 0 || !state.gameVideo || !videoRect || videoRect.width === 0) return null;

        const gameScreenCenterX = videoRect.left + videoRect.width / 2;
        const gameScreenCenterY = videoRect.top + videoRect.height / 2;

        let bestTarget = null;
        let bestScore = Infinity;

        const fovCenterX = config.visual.fovCircle.centerOnGameScreen ? gameScreenCenterX : state.input.lastMouseX;
        const fovCenterY = config.visual.fovCircle.centerOnGameScreen ? gameScreenCenterY : state.input.lastMouseY;

        predictions.forEach(prediction => {
            const targetInfo = calculateAimTarget(prediction, videoRect);
            if (!targetInfo) return;

            const dx_fov = targetInfo.x - fovCenterX;
            const dy_fov = targetInfo.y - fovCenterY;

            if (Math.sqrt(dx_fov * dx_fov + dy_fov * dy_fov) > config.aim.fovRadius) return;

            let referenceX, referenceY;
            if (config.aim.targetPriority === "center") {
                referenceX = gameScreenCenterX;
                referenceY = gameScreenCenterY;
            } else {
                referenceX = state.input.lastMouseX;
                referenceY = state.input.lastMouseY;
            }

            const dx_priority = targetInfo.x - referenceX;
            const dy_priority = targetInfo.y - referenceY;
            const distanceToPriorityPoint = Math.sqrt(dx_priority * dx_priority + dy_priority * dy_priority);

            let score;
            switch (config.aim.targetPriority) {
                case "size":
                    score = targetInfo.width * targetInfo.height > 0 ? 1 / (targetInfo.width * targetInfo.height) : Infinity;
                    break;
                case "distance":
                case "center":
                case "crosshair":
                default:
                    score = distanceToPriorityPoint;
                    break;
            }

            if (score < bestScore) {
                bestScore = score;
                bestTarget = { prediction, screenPosition: targetInfo, distance: distanceToPriorityPoint, score: prediction.score };
            }
        });
        return bestTarget;
    }

    // === Input Controller ===
    const InputController = {
        init() {
            state.input.lastMouseX = window.innerWidth / 2;
            state.input.lastMouseY = window.innerHeight / 2;
            document.addEventListener('mousemove', e => {
                state.input.lastMouseX = e.clientX;
                state.input.lastMouseY = e.clientY;
            });
            this.setupKeyMonitoring();
            debug.log("Input controller initialized");
            return true;
        },
        setupKeyMonitoring() {
            document.addEventListener('keydown', e => {
                state.input.activeKeys.add(e.code);
                if (e.code === config.game.controlOptions.crouchKey) debug.log(`Crouch key pressed (${e.code})`);
                if (e.code === config.aim.activationKey) debug.log(`Aim activation key (${e.code}) pressed.`);
                config.game.controlOptions.weaponKeys.forEach((k, i) => {
                    if (e.code === k) {
                        state.currentWeapon = i;
                        debug.log(`Switched to weapon slot ${i + 1}`);
                    }
                });
            });
            document.addEventListener('keyup', e => {
                state.input.activeKeys.delete(e.code);
                if (e.code === config.aim.activationKey) debug.log(`Aim activation key (${e.code}) released.`);
            });
            document.addEventListener('mousedown', e => {
                if (e.button === 0) state.input.leftButtonDown = true;
                if (e.button === 2) state.input.rightButtonDown = true;
            });
            document.addEventListener('mouseup', e => {
                if (e.button === 0) state.input.leftButtonDown = false;
                if (e.button === 2) state.input.rightButtonDown = false;
            });
        },
        // --- CUSTOM AIM MOVEMENT ---
        // This function implements your "one step at a time" logic with slowdown.
        moveMouseTo(targetScreenX, targetScreenY) {
            if (!state.gameVideo) return;
            const videoRect = state.gameVideo.getBoundingClientRect();
            if (!videoRect || videoRect.width === 0) return;

            const currentCursorX = state.input.lastMouseX;
            const currentCursorY = state.input.lastMouseY;

            let errorX = targetScreenX - currentCursorX;
            let errorY = targetScreenY - currentCursorY;

            // Calculate current distance to target
            const distanceToTarget = Math.sqrt(errorX * errorX + errorY * errorY);

            // Determine movement speed based on distance
            let movementFraction;
            if (distanceToTarget <= config.aim.slowdownThresholdPixels) {
                // Inside slowdown zone, use slowdown speed
                movementFraction = config.aim.slowdownMovementSpeed;
            } else {
                // Outside slowdown zone, use normal speed
                movementFraction = config.aim.normalMovementSpeed;
            }

            // Calculate actual movement for this frame
            const moveX = errorX * movementFraction;
            const moveY = errorY * movementFraction;

            // Round movements to whole pixels for dispatching PointerEvent
            const finalMoveX = Math.round(moveX);
            const finalMoveY = Math.round(moveY);

            // Only move if there's a significant enough pixel movement
            if (Math.abs(finalMoveX) < 1 && Math.abs(finalMoveY) < 1 && distanceToTarget < config.aim.slowdownThresholdPixels) {
                return; // Stop small movements when very close and within slowdown zone
            }

            // Dispatch PointerEvent to simulate mouse movement
            const targetElement = document.querySelector(config.game.containerSelector) || state.gameVideo || document.documentElement;
            const pointerMoveEvent = new PointerEvent('pointermove', {
                bubbles: true, cancelable: true, view: window,
                clientX: Math.round(currentCursorX + finalMoveX),
                clientY: Math.round(currentCursorY + finalMoveY),
                screenX: Math.round(currentCursorX + finalMoveX),
                screenY: Math.round(currentCursorY + finalMoveY),
                movementX: finalMoveX, // This is the key for relative movement
                movementY: finalMoveY,
                buttons: (state.input.leftButtonDown ? 1 : 0) | (state.input.rightButtonDown ? 2 : 0),
                pointerType: 'mouse', isPrimary: true
            });
            targetElement.dispatchEvent(pointerMoveEvent);

            // Update internal mouse position to reflect the dispatched movement
            state.input.lastMouseX += finalMoveX;
            state.input.lastMouseY += finalMoveY;
        },
        startShooting() {
            if (state.isShooting) return;
            const targetElement = document.querySelector(config.game.containerSelector) || state.gameVideo || document.documentElement;
            const pointerDownEvent = new PointerEvent('pointerdown', {
                bubbles: true, cancelable: true, view: window,
                clientX: Math.round(state.input.lastMouseX), clientY: Math.round(state.input.lastMouseY),
                button: 0, buttons: 1, pointerType: 'mouse', isPrimary: true
            });
            targetElement.dispatchEvent(pointerDownEvent);
            state.isShooting = true;
            debug.log("Shooting started (simulated by aimbot)");
            if (config.game.controlOptions.crouchOnShoot && !state.input.activeKeys.has(config.game.controlOptions.crouchKey)) {
                this.pressKey(config.game.controlOptions.crouchKey, 0);
            }
        },
        stopShooting() {
            if (!state.isShooting) return;
            const targetElement = document.querySelector(config.game.containerSelector) || state.gameVideo || document.documentElement;
            const pointerUpEvent = new PointerEvent('pointerup', {
                bubbles: true, cancelable: true, view: window,
                clientX: Math.round(state.input.lastMouseX), clientY: Math.round(state.input.lastMouseY),
                button: 0, buttons: 0, pointerType: 'mouse', isPrimary: true
            });
            targetElement.dispatchEvent(pointerUpEvent);
            state.isShooting = false;
            debug.log("Shooting stopped (simulated by aimbot)");
            if (config.game.controlOptions.crouchOnShoot && state.input.activeKeys.has(config.game.controlOptions.crouchKey)) {
                this.releaseKey(config.game.controlOptions.crouchKey);
            }
        },
        pressKey(keyCode, duration = 50) {
            const keyChar = keyCode.replace(/^(Key|Digit)/, '');
            const targetElement = document.activeElement || document.body;
            const keyDownEvent = new KeyboardEvent('keydown', {
                code: keyCode, key: keyChar, keyCode: keyCode.startsWith('Digit') ? parseInt(keyChar) + 48 : keyChar.length === 1 ? keyChar.charCodeAt(0) : 0,
                bubbles: true, cancelable: true, view: window
            });
            targetElement.dispatchEvent(keyDownEvent);
            state.input.activeKeys.add(keyCode);
            if (duration > 0) setTimeout(() => this.releaseKey(keyCode), duration);
        },
        releaseKey(keyCode) {
            const keyChar = keyCode.replace(/^(Key|Digit)/, '');
            const targetElement = document.activeElement || document.body;
            const keyUpEvent = new KeyboardEvent('keyup', {
                code: keyCode, key: keyChar, keyCode: keyCode.startsWith('Digit') ? parseInt(keyChar) + 48 : keyChar.length === 1 ? keyChar.charCodeAt(0) : 0,
                bubbles: true, cancelable: true, view: window
            });
            targetElement.dispatchEvent(keyUpEvent);
            state.input.activeKeys.delete(keyCode);
        },
        reload() {
            this.pressKey(config.game.controlOptions.reloadKey, 50);
            debug.log("Reload key pressed");
        },
        switchWeapon(slotIndex) {
            if (slotIndex >= 0 && slotIndex < config.game.controlOptions.weaponKeys.length) {
                this.pressKey(config.game.controlOptions.weaponKeys[slotIndex], 50);
                state.currentWeapon = slotIndex;
                debug.log(`Switched to weapon slot ${slotIndex + 1}`);
            }
        }
    };

    // === Visual Rendering Functions ===
    function createOverlayCanvas() {
        if (state.ui.overlayCanvas) return;
        const canvas = document.createElement('canvas');
        canvas.id = 'xcloud-aimbot-overlay';
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        canvas.style.cssText = 'position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:99999;';
        state.ui.overlayCanvas = canvas;
        state.ui.overlayCtx = canvas.getContext('2d');
        document.body.appendChild(canvas);
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
        debug.log("Overlay canvas created");
    }

    function drawCrosshair(videoRect) {
        if (!state.ui.overlayCtx || !config.visual.crosshair.enabled) return;
        const ctx = state.ui.overlayCtx;
        let cX, cY;
        if (config.visual.crosshair.centerOnGameScreen && videoRect && videoRect.width > 0) {
            cX = videoRect.left + videoRect.width / 2;
            cY = videoRect.top + videoRect.height / 2;
        } else {
            cX = state.input.lastMouseX;
            cY = state.input.lastMouseY;
        }
        const s = config.visual.crosshair.size;
        ctx.strokeStyle = config.visual.crosshair.color;
        ctx.fillStyle = config.visual.crosshair.color;
        ctx.lineWidth = 1;
        switch (config.visual.crosshair.style) {
            case 'cross':
                ctx.beginPath();
                ctx.moveTo(cX - 2 * s, cY); ctx.lineTo(cX + 2 * s, cY);
                ctx.moveTo(cX, cY - 2 * s); ctx.lineTo(cX, cY + 2 * s);
                ctx.stroke();
                break;
            case 'dot':
                ctx.beginPath();
                ctx.arc(cX, cY, s, 0, 2 * Math.PI);
                ctx.fill();
                break;
            case 'circle':
                ctx.beginPath();
                ctx.arc(cX, cY, 2 * s, 0, 2 * Math.PI);
                ctx.stroke();
                break;
        }
        return { x: cX, y: cY };
    }

    function drawKeypoints(players, videoRect) {
        if (!config.visual.keypoints.enabled || !state.ui.overlayCtx || !players || players.length === 0 || !videoRect) return;
        const ctx = state.ui.overlayCtx;
        players.forEach(p => {
            if (p.keypoints) {
                p.keypoints.forEach(kP => {
                    if (kP.score && kP.score >= config.detection.keypointConfidence) {
                        const sX = videoRect.left + kP.x / state.gameVideo.videoWidth * videoRect.width;
                        const sY = videoRect.top + kP.y / state.gameVideo.videoHeight * videoRect.height;
                        ctx.beginPath();
                        ctx.arc(sX, sY, config.visual.keypoints.radius, 0, 2 * Math.PI);
                        ctx.fillStyle = config.visual.keypoints.color;
                        ctx.fill();
                    }
                });
            }
        });
    }

    function drawBoundingBoxes(players, videoRect) {
        if (!config.visual.boundingBoxes.enabled || !state.ui.overlayCtx || !players || players.length === 0 || !videoRect) return;
        const ctx = state.ui.overlayCtx;
        players.forEach(p => {
            const [rawX, rawY, rawWidth, rawHeight] = p.bbox;
            const screenX = videoRect.left + rawX / state.gameVideo.videoWidth * videoRect.width;
            const screenY = videoRect.top + rawY / state.gameVideo.videoHeight * videoRect.height;
            const screenWidth = rawWidth / state.gameVideo.videoWidth * videoRect.width;
            const screenHeight = rawHeight / state.gameVideo.videoHeight * videoRect.height;

            ctx.strokeStyle = config.visual.boundingBoxes.color;
            ctx.lineWidth = config.visual.boundingBoxes.lineWidth;
            ctx.strokeRect(screenX, screenY, screenWidth, screenHeight);

            if (config.visual.boundingBoxes.showInfo) {
                ctx.fillStyle = config.visual.boundingBoxes.color;
                ctx.font = '12px Arial';
                const scoreText = `${(100 * p.score).toFixed(0)}%`;
                ctx.fillText(scoreText, screenX + 5, screenY + 15);
                if (p.keypoints && config.visual.boundingBoxes.fromKeypoints) {
                    const keypointsConfCount = p.keypoints.filter(kP => kP.score >= config.detection.keypointConfidence).length;
                    ctx.fillText(`KPs: ${keypointsConfCount}`, screenX + 5, screenY + 30);
                }
            }
        });
    }

    const SKELETON_CONNECTIONS = [
        ['left_shoulder', 'right_shoulder'], ['left_hip', 'right_hip'], ['left_shoulder', 'left_hip'], ['right_shoulder', 'right_hip'],
        ['left_shoulder', 'left_elbow'], ['left_elbow', 'left_wrist'], ['right_shoulder', 'right_elbow'], ['right_elbow', 'right_wrist'],
        ['left_hip', 'left_knee'], ['left_knee', 'left_ankle'], ['right_hip', 'right_knee'], ['right_knee', 'right_ankle'],
        ['nose', 'left_eye'], ['left_eye', 'left_ear'], ['nose', 'right_eye'], ['right_eye', 'right_ear'],
        ['left_ear', 'left_shoulder'], ['right_ear', 'right_shoulder']
    ];

    function drawSkeleton(players, videoRect) {
        if (!config.visual.skeleton.enabled || !state.ui.overlayCtx || !players || players.length === 0 || !videoRect) return;
        const ctx = state.ui.overlayCtx;
        ctx.strokeStyle = config.visual.skeleton.color;
        ctx.lineWidth = config.visual.skeleton.lineWidth;
        players.forEach(player => {
            if (player.keypoints) {
                const keypointsMap = new Map();
                player.keypoints.forEach(kp => {
                    if (kp.score && kp.score >= config.detection.keypointConfidence) {
                        keypointsMap.set(kp.name, {
                            x: videoRect.left + (kp.x / state.gameVideo.videoWidth) * videoRect.width,
                            y: videoRect.top + (kp.y / state.gameVideo.videoHeight) * videoRect.height
                        });
                    }
                });
                SKELETON_CONNECTIONS.forEach(pair => {
                    const kp1 = keypointsMap.get(pair[0]);
                    const kp2 = keypointsMap.get(pair[1]);
                    if (kp1 && kp2) {
                        ctx.beginPath();
                        ctx.moveTo(kp1.x, kp1.y);
                        ctx.lineTo(kp2.x, kp2.y);
                        ctx.stroke();
                    }
                });
            }
        });
    }

    function drawTargetLockIndicator(targetInfo, videoRect) {
        if (!config.visual.targetLock.enabled || !state.ui.overlayCtx || !targetInfo || !videoRect) return null;
        const ctx = state.ui.overlayCtx;
        const [rawX, rawY, rawWidth, rawHeight] = targetInfo.prediction.bbox;
        const screenX = videoRect.left + rawX / state.gameVideo.videoWidth * videoRect.width;
        const screenY = videoRect.top + rawY / state.gameVideo.videoHeight * videoRect.height;
        const screenWidth = rawWidth / state.gameVideo.videoWidth * videoRect.width;
        const screenHeight = rawHeight / state.gameVideo.videoHeight * videoRect.height;

        ctx.strokeStyle = config.visual.targetLock.color;
        ctx.lineWidth = 2;
        const cornerSize = 0.2 * Math.min(screenWidth, screenHeight);
        const crosshairSize = 10;

        switch (config.visual.targetLock.style) {
            case 'full':
                ctx.strokeRect(screenX, screenY, screenWidth, screenHeight);
                break;
            case 'corners':
                ctx.beginPath();
                ctx.moveTo(screenX + cornerSize, screenY); ctx.lineTo(screenX, screenY); ctx.lineTo(screenX, screenY + cornerSize);
                ctx.moveTo(screenX + screenWidth - cornerSize, screenY); ctx.lineTo(screenX + screenWidth, screenY); ctx.lineTo(screenX + screenWidth, screenY + cornerSize);
                ctx.moveTo(screenX + cornerSize, screenY + screenHeight); ctx.lineTo(screenX, screenY + screenHeight); ctx.lineTo(screenX, screenY + screenHeight - cornerSize);
                ctx.moveTo(screenX + screenWidth - cornerSize, screenY + screenHeight); ctx.lineTo(screenX + screenWidth, screenY + screenHeight); ctx.lineTo(screenX + screenWidth, screenY + screenHeight - cornerSize);
                ctx.stroke();
                break;
            case 'crosshair':
                ctx.beginPath();
                ctx.moveTo(targetInfo.screenPosition.x - crosshairSize, targetInfo.screenPosition.y);
                ctx.lineTo(targetInfo.screenPosition.x + crosshairSize, targetInfo.screenPosition.y);
                ctx.moveTo(targetInfo.screenPosition.x, targetInfo.screenPosition.y - crosshairSize);
                ctx.lineTo(targetInfo.screenPosition.x, targetInfo.screenPosition.y + crosshairSize);
                ctx.stroke();
                break;
        }
        return { x: screenX, y: screenY, width: screenWidth, height: screenHeight };
    }

    function drawFOVCircle(videoRect) {
        if (!config.visual.fovCircle.enabled || !state.ui.overlayCtx) return;
        if (config.visual.fovCircle.showOnlyWhenAiming && !state.input.activeKeys.has(config.aim.activationKey)) return;
        const ctx = state.ui.overlayCtx;
        let cX, cY;
        if (config.visual.fovCircle.centerOnGameScreen && videoRect && videoRect.width > 0) {
            cX = videoRect.left + videoRect.width / 2;
            cY = videoRect.top + videoRect.height / 2;
        } else {
            cX = state.input.lastMouseX;
            cY = state.input.lastMouseY;
        }
        ctx.strokeStyle = config.visual.fovCircle.color;
        ctx.lineWidth = config.visual.fovCircle.lineWidth;
        ctx.beginPath();
        ctx.arc(cX, cY, config.aim.fovRadius, 0, 2 * Math.PI);
        ctx.stroke();
    }

    // NEW: Function to draw the target dot
    function drawTargetDot(targetInfo) {
        if (!config.visual.targetDot.enabled || !state.ui.overlayCtx || !targetInfo) return;
        const ctx = state.ui.overlayCtx;
        ctx.beginPath();
        ctx.arc(targetInfo.screenPosition.x, targetInfo.screenPosition.y, config.visual.targetDot.radius, 0, 2 * Math.PI);
        ctx.fillStyle = config.visual.targetDot.color;
        ctx.fill();
    }

    function drawPerformanceMetrics() {
        if (!config.visual.performanceMetrics.enabled || !state.ui.overlayCtx) return;
        const ctx = state.ui.overlayCtx;
        const metrics = [
            `FPS: ${state.performance.fps}`,
            `Detect: ${state.performance.detectionTime.toFixed(1)}ms (Avg: ${state.performance.avgDetectionTime.toFixed(1)}ms)`,
            `Skip Frames: ${config.detection.skipFrames}`
        ];
        ctx.font = '14px Arial';
        ctx.fillStyle = 'rgba(0,255,0,0.8)';
        const lineHeight = 16;
        let startX = 10, startY = 20;
        switch (config.visual.performanceMetrics.position) {
            case 'top-right':
                startX = state.ui.overlayCanvas.width - 200;
                break;
            case 'bottom-left':
                startY = state.ui.overlayCanvas.height - metrics.length * lineHeight - 10;
                break;
            case 'bottom-right':
                startX = state.ui.overlayCanvas.width - 200;
                startY = state.ui.overlayCanvas.height - metrics.length * lineHeight - 10;
                break;
        }
        metrics.forEach((metric, i) => ctx.fillText(metric, startX, startY + i * lineHeight));
    }

    function drawDebugInfo() {
        if (!config.visual.showDebugInfo || !state.ui.overlayCtx) return;
        const ctx = state.ui.overlayCtx;
        const aimingActive = state.input.activeKeys.has(config.aim.activationKey);
        const debugLines = [
            `Target: ${state.currentTarget ? `Yes (Score: ${state.currentTarget.score.toFixed(2)})` : "No"}`,
            `Shooting: ${state.isShooting ? "Yes" : "No"} | Aiming (${config.aim.activationKey.replace('Key', '')})${aimingActive ? " (Active)" : " (Inactive)"}`,
            `OS Mouse: X:${state.input.lastMouseX.toFixed(0)} Y:${state.input.lastMouseY.toFixed(0)}`
        ];
        ctx.font = '12px Arial';
        ctx.fillStyle = 'rgba(255,255,0,0.8)';
        const lineHeight = 15;
        let startY = 80;
        if (config.visual.performanceMetrics.enabled && config.visual.performanceMetrics.position === 'top-left') {
            startY = 20 + (state.performance.fps > 0 ? 3 : 2) * 16 + 20;
        }
        let startX = 10;
        if (config.visual.performanceMetrics.enabled && (config.visual.performanceMetrics.position === 'bottom-left' || config.visual.performanceMetrics.position === 'bottom-right') && config.visual.showDebugInfo) {
            startY = state.ui.overlayCanvas.height - (state.performance.fps > 0 ? 3 : 2) * 16 - 10 - debugLines.length * lineHeight - 10;
        }
        debugLines.forEach((line, i) => ctx.fillText(line, startX, startY + i * lineHeight));
    }

    function drawVisuals(players, currentTarget, hasTargetInFOV) {
        if (!state.ui.overlayCtx) return;
        const ctx = state.ui.overlayCtx;
        const canvas = state.ui.overlayCanvas;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const videoRect = state.gameVideo ? state.gameVideo.getBoundingClientRect() : null;
        const isAimKeyHeld = state.input.activeKeys.has(config.aim.activationKey);

        const crosshairPos = drawCrosshair(videoRect);
        drawFOVCircle(videoRect);
        drawPerformanceMetrics();
        drawDebugInfo();

        if (isAimKeyHeld && hasTargetInFOV && videoRect && videoRect.width > 0) {
            drawKeypoints(players, videoRect);
            drawSkeleton(players, videoRect);
            drawBoundingBoxes(players, videoRect);

            if (config.visual.targetDot.enabled && currentTarget) {
                drawTargetDot(currentTarget);
            }

            if (config.visual.targetLock.enabled && currentTarget) {
                const targetLockRect = drawTargetLockIndicator(currentTarget, videoRect);

                if (config.game.autoShoot && crosshairPos && targetLockRect) {
                    const { x: cX, y: cY } = crosshairPos;
                    const { x: tX, y: tY, width: tW, height: tH } = targetLockRect;

                    if (cX >= tX && cX <= tX + tW && cY >= tY && cY <= tY + tH) {
                        if (!state.isShooting) {
                            InputController.startShooting();
                        } else if (config.game.triggerOptions.burstMode) {
                            const now = performance.now();
                            if (now - state.recoilState.lastShotTime > config.game.triggerOptions.burstInterval) {
                                InputController.stopShooting();
                                InputController.startShooting();
                                state.recoilState.lastShotTime = now;
                            }
                        }
                    } else if (state.isShooting && !config.game.triggerOptions.burstMode) {
                        InputController.stopShooting();
                    }
                } else if (state.isShooting && !config.game.triggerOptions.burstMode) {
                    InputController.stopShooting();
                }
            }
        } else if (state.isShooting && !config.game.triggerOptions.burstMode) {
            InputController.stopShooting();
        }
    }

    // === Main Loop and Initialization ===
    async function processAimingLoop(timestamp) {
        const isAimKeyHeld = state.input.activeKeys.has(config.aim.activationKey);
        const shouldRunDetection = config.detection.enabled && (isAimKeyHeld || (config.game.autoShoot && !isAimKeyHeld));

        if (!shouldRunDetection) {
            state.currentTarget = null;
            drawVisuals([], null, false);
            if (state.isShooting && !config.game.triggerOptions.burstMode) {
                InputController.stopShooting();
            }
            return;
        }

        const videoRect = state.gameVideo ? state.gameVideo.getBoundingClientRect() : null;
        const players = await detectPlayers(videoRect);
        const newTarget = findBestTarget(players, videoRect);
        const hasTargetInFOV = newTarget !== null;

        if (newTarget) {
            if (!state.currentTarget || newTarget.prediction !== state.currentTarget.prediction) {
                const now = performance.now();
                if (!state.currentTarget || now - state.lastTargetSwitch > config.aim.targetSwitchCooldown) {
                    debug.log(`New target acquired: Score ${newTarget.score.toFixed(2)}, dist: ${newTarget.distance.toFixed(0)}px`);
                    state.currentTarget = newTarget;
                    state.lastTargetSwitch = now;
                }
            } else {
                state.currentTarget = newTarget;
            }
        } else {
            state.currentTarget = null;
        }

        drawVisuals(players, state.currentTarget, hasTargetInFOV);

        if (state.currentTarget) {
            let { x: targetX, y: targetY } = state.currentTarget.screenPosition;
            InputController.moveMouseTo(targetX, targetY);
        }
    }

    async function detectPlayers(videoRect) {
        if (!state.input.activeKeys.has(config.aim.activationKey)) {
            return [];
        }
        if (!state.gameVideo || !state.modelLoaded || !state.detectionModel ||
            state.gameVideo.paused || state.gameVideo.ended ||
            state.gameVideo.videoWidth === 0 || state.gameVideo.videoHeight === 0 || !videoRect) {
            return [];
        }

        state.frameCount++;
        if (state.frameCount % (config.detection.skipFrames + 1) !== 0) {
            return [];
        }

        const now = performance.now();
        if (now - state.lastDetectionTime < config.detection.processingInterval) {
            return [];
        }

        let videoSource = state.gameVideo;

        // --- Use OffscreenCanvas for AI processing if supported and enabled ---
        if (config.detection.useOffscreenCanvas && config.detection.enabled && state.gameVideo.videoWidth > 0 && state.gameVideo.videoHeight > 0) {
            if (!state.ui.offscreenCanvas) {
                state.ui.offscreenCanvas = new OffscreenCanvas(state.gameVideo.videoWidth, state.gameVideo.videoHeight);
                state.ui.offscreenCtx = state.ui.offscreenCanvas.getContext('2d');
                debug.log("OffscreenCanvas created for AI processing.");
            } else if (state.ui.offscreenCanvas.width !== state.gameVideo.videoWidth || state.ui.offscreenCanvas.height !== state.gameVideo.videoHeight) {
                state.ui.offscreenCanvas.width = state.gameVideo.videoWidth;
                state.ui.offscreenCanvas.height = state.gameVideo.videoHeight;
                debug.log("OffscreenCanvas resized for AI processing.");
            }
            // Draw current video frame onto offscreen canvas
            state.ui.offscreenCtx.drawImage(state.gameVideo, 0, 0, state.gameVideo.videoWidth, state.gameVideo.videoHeight);

            // Apply ignore self region on the offscreen canvas (will be drawn black)
            if (config.detection.ignoreSelfRegion.enabled) {
                const region = config.detection.ignoreSelfRegion;
                const rectX = state.gameVideo.videoWidth * region.xPercent;
                const rectY = state.gameVideo.videoHeight * region.yPercent;
                const rectW = state.gameVideo.videoWidth * region.widthPercent;
                const rectH = state.gameVideo.videoHeight * region.heightPercent;
                state.ui.offscreenCtx.fillStyle = 'rgba(0, 0, 0, 1)';
                state.ui.offscreenCtx.fillRect(rectX, rectY, rectW, rectH);
            }
            videoSource = state.ui.offscreenCanvas; // AI model uses this offscreen canvas as its input source
        } else if (config.detection.ignoreSelfRegion.enabled) {
            debug.warn("OffscreenCanvas not available or not used. Ignore Self Region might not work as intended or impact performance.");
        }

        try {
            const detectionStart = performance.now();
            // Perform pose estimation on the chosen video source (main video element or offscreen canvas)
            const poses = await state.detectionModel.estimatePoses(videoSource, { flipHorizontal: false });
            const detectionEnd = performance.now();
            state.performance.detectionTime = detectionEnd - detectionStart;

            state.performance.detectionTimeHistory.push(state.performance.detectionTime);
            if (state.performance.detectionTimeHistory.length > 30) state.performance.detectionTimeHistory.shift();
            state.performance.avgDetectionTime = state.performance.detectionTimeHistory.reduce((a, b) => a + b, 0) / state.performance.detectionTimeHistory.length;
            state.lastDetectionTime = now;

            if (config.detection.dynamicFrameSkipping.enabled) {
                const dynConfig = config.detection.dynamicFrameSkipping;
                const prevSkipFrames = config.detection.skipFrames;
                
                if (state.performance.avgDetectionTime > dynConfig.highDetectionTimeThreshold || state.performance.fps < dynConfig.fpsThresholdLow) {
                    config.detection.skipFrames = Math.min(config.detection.skipFrames + 1, dynConfig.maxSkipFrames);
                } else if (state.performance.avgDetectionTime < dynConfig.lowDetectionTimeThreshold && state.performance.fps > dynConfig.fpsThresholdHigh) {
                    config.detection.skipFrames = Math.max(config.detection.skipFrames - 1, dynConfig.minSkipFrames);
                }
                
                if (prevSkipFrames !== config.detection.skipFrames) {
                    debug.log(`Dynamic frame-skipping adjusted: skipFrames=${config.detection.skipFrames} (FPS: ${state.performance.fps}, Avg Detect: ${state.performance.avgDetectionTime.toFixed(1)}ms)`);
                }
            }

            const results = [];
            if (poses && poses.length > 0) {
                const fovCenterX = config.visual.fovCircle.centerOnGameScreen ? (videoRect.left + videoRect.width / 2) : state.input.lastMouseX;
                const fovCenterY = config.visual.fovCircle.centerOnGameScreen ? (videoRect.top + videoRect.height / 2) : state.input.lastMouseY;

                for (const pose of poses) {
                    if (pose.score && pose.score >= config.detection.detectorConfig.minPoseScore) {
                        const bbox = calculateBoundingBoxFromKeypoints(pose.keypoints);
                        if (bbox && bbox.width > 0 && bbox.height > 0) {
                            const screenBboxCenterX = videoRect.left + (bbox.x + bbox.width / 2) / state.gameVideo.videoWidth * videoRect.width;
                            const screenBboxCenterY = videoRect.top + (bbox.y + bbox.height / 2) / state.gameVideo.videoHeight * videoRect.height;
                            const dx_fov = screenBboxCenterX - fovCenterX;
                            const dy_fov = screenBboxCenterY - fovCenterY;

                            if (Math.sqrt(dx_fov * dx_fov + dy_fov * dy_fov) <= config.aim.fovRadius) {
                                results.push({ class: 'person', score: pose.score, bbox: [bbox.x, bbox.y, bbox.width, bbox.height], keypoints: pose.keypoints });
                            }
                        }
                    }
                }
            }
            return results.slice(0, config.detection.maxDetections);
        } catch (err) {
            debug.error("Error during pose estimation:", err);
            return [];
        }
    }

    function startAimbotLoop() {
        debug.log("Starting main aimbot loop");
        async function mainLoop(timestamp) {
            requestAnimationFrame(mainLoop);

            state.performance.framesThisSecond++;
            if (timestamp - state.performance.lastFpsUpdate >= 1000) {
                state.performance.fps = state.performance.framesThisSecond;
                state.performance.framesThisSecond = 0;
                state.performance.lastFpsUpdate = timestamp;
            }

            if (!state.gameVideo || state.gameVideo.paused || state.gameVideo.ended || state.gameVideo.videoWidth === 0) {
                if (state.isShooting) InputController.stopShooting();
                if (state.ui.overlayCtx) state.ui.overlayCtx.clearRect(0, 0, state.ui.overlayCanvas.width, state.ui.overlayCanvas.height);
                state.currentTarget = null;
                return;
            }
            await processAimingLoop(timestamp);
        }
        requestAnimationFrame(mainLoop);
    }

    async function initializeAimbot() {
        debug.log(`Initializing Aimbot V${config.version} (MoveNet)...`);

        state.gameVideo = document.querySelector(config.game.videoSelector);
        if (!state.gameVideo) {
            debug.error("Game video element not found. Retrying in 3 seconds...");
            showNotification("Error: Game video not found! Aimbot cannot start.", "error", 5000);
            setTimeout(initializeAimbot, 3000);
            return;
        }
        debug.log("Game video element found:", state.gameVideo);

        if (state.gameVideo.readyState < state.gameVideo.HAVE_METADATA) {
            debug.log("Waiting for video metadata...");
            try {
                await new Promise((resolve, reject) => {
                    state.gameVideo.onloadedmetadata = resolve;
                    state.gameVideo.onerror = reject;
                });
                debug.log(`Video metadata loaded: ${state.gameVideo.videoWidth}x${state.gameVideo.videoHeight}`);
            } catch (videoError) {
                debug.error("Error loading video metadata:", videoError);
                showNotification("Error loading video. Aimbot might not work correctly.", "error");
                setTimeout(initializeAimbot, 5000);
                return;
            }
        } else {
            debug.log(`Video dimensions readily available: ${state.gameVideo.videoWidth}x${state.gameVideo.videoHeight}`);
        }

        createOverlayCanvas();
        if (!InputController.init()) {
            debug.error("Input controller failed to initialize.");
            showNotification("Error: Input controller init failed!", "error");
            return;
        }

        if (config.detection.enabled) {
            if (!await loadDetectionModel()) {
                debug.error("Detection model (MoveNet) failed to load. Detection features disabled.");
            }
        } else {
            debug.log("AI Detection is disabled in config.");
            showNotification("AI Detection is disabled.", "info");
        }

        startAimbotLoop();
        debug.log("Aimbot (MoveNet) initialized and main loop started.");
        showNotification(`Precision Aimbot V${config.version} (MoveNet) Initialized!`, "info");
    }

    if (document.readyState === 'complete' || document.readyState === 'interactive') {
        setTimeout(initializeAimbot, 2500);
    } else {
        window.addEventListener('load', () => setTimeout(initializeAimbot, 2500));
    }
})();
