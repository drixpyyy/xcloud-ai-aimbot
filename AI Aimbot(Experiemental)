//
// --- Aimbot Payload (executed after dependencies) ---
//
function executeAimbotPayload() {
    (function() {
        // =================================================================================================
        // CONFIGURATION
        // =================================================================================================
        const config = {
            detection: {
                enabled: true,
                betterDetection: {
                    enabled: true
                },
                modelType: poseDetection.SupportedModels.MoveNet,
                detectorConfig: {
                    modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING,
                    enableSmoothing: true,
                    minPoseScore: 0.25
                },
                keypointConfidence: 0.20,
                maxDetections: 5,
                processingInterval: 5,
                skipFrames: 5,
                ignoreSelfRegion: {
                    enabled: true,
                    xPercent: 0.00,
                    yPercent: 0.27,
                    widthPercent: 0.43,
                    heightPercent: 0.73
                }
            },
            game: {
                videoSelector: 'video[aria-label="Game Stream for unknown title"]',
                containerSelector: '#game-stream',
                autoShoot: false,
                triggerOptions: {
                    delayBeforeShoot: 10,
                    burstMode: false,
                    burstCount: 3,
                    burstInterval: 100
                }
            },
            aim: {
                alwaysOn: {
                    enabled: false
                },
                activationKey: 'MouseRight',
                activationButton: 'A',
                toggleMode: false,
                fovRadius: 136,
                aimPoint: "nose",
                headOffset: 0.15,
                bodyOffset: 0.4,
                targetPriority: "center",
                targetSwitchCooldown: 0,
                triggerThreshold: 0.7,
                aimSpeed: {
                    enabled: true,
                    speedPercent: 45.0
                },
                smartSlowdown: {
                    enabled: true,
                    maxSpeed: 100.0,
                    minSpeed: 25.0,
                    slowdownRadius: 90,
                    nonlinear: {
                        enabled: false,
                        exponent: 1.5
                    },
                    prediction: {
                        enabled: true
                    },
                    velocityBoostFactor: 0.5,
                    fpsCompensation: true,
                    minFpsThreshold: 30
                },
                prediction: {
                    enabled: true,
                    latencyCompensation: 50,
                    jitterBufferSize: 3,
                    maxVelocity: 1000,
                    smoothingFactor: 0.2,
                    predictionScale: 1.2
                }
            },
            controller: {
                enabled: false,
                useVirtualGamepad: false,
                deadZone: 0.2,
                sensitivity: {
                    x: 2.0,
                    y: 2.0
                },
                shootButton: 'RT',
                aimButton: 'LT'
            },
            visual: {
                showDebugInfo: false,
                esp: {
                    showOnlyWhenAiming: true
                },
                crosshair: {
                    enabled: false,
                    style: 'dot',
                    color: 'black',
                    size: 3,
                    centerOnGameScreen: true
                },
                targetLock: {
                    enabled: false,
                    style: 'full',
                    color: 'red',
                    lineWidth: 2,
                    fillEnabled: true,
                    fillColor: 'rgba(255, 0, 0, 0.2)',
                    gradient: {
                        enabled: true,
                        speed: 0.5
                    }
                },
                skeleton: {
                    enabled: false,
                    color: 'white',
                    lineWidth: 2,
                    gradient: {
                        enabled: true,
                        speed: 0.5
                    }
                },
                headDot: {
                    enabled: false,
                    color: 'cyan',
                    size: 4
                },
                aimPoint: {
                    enabled: false,
                    style: 'cross',
                    color: 'rgba(255, 255, 0, 0.9)',
                    size: 8,
                    lineWidth: 1
                },
                tracers: {
                    enabled: false,
                    color: 'rgba(255, 255, 255, 0.9)',
                    lineWidth: 1
                },
                fovCircle: {
                    enabled: false,
                    color: 'rgba(255,255,255,0.3)',
                    lineWidth: 1,
                    centerOnGameScreen: true,
                    showOnlyWhenAiming: true,
                    gradient: {
                        enabled: false,
                        speed: 0.5
                    }
                },
                performanceMetrics: {
                    enabled: false,
                    position: 'top-left'
                },
                drawIgnoreRegion: {
                    enabled: false,
                    color: 'rgba(50, 50, 50, 0.4)',
                    lineWidth: 1,
                    showOnlyWhenAiming: true
                }
            }
        };

        const state = {
            gameVideo: null,
            detectionModel: null,
            modelLoaded: false,
            currentTarget: null,
            lastTargetSwitch: 0,
            frameCount: 0,
            lastDetectionTime: 0,
            rainbowHue: 0,
            performance: {
                fps: 0,
                framesThisSecond: 0,
                lastFpsUpdate: 0,
                detectionTime: 0,
                avgDetectionTime: 0,
                detectionTimeHistory: []
            },
            ui: {
                overlayCanvas: null,
                overlayCtx: null,
                offscreenCanvas: null,
                offscreenCtx: null
            },
            input: {
                lastMouseX: window.innerWidth / 2,
                lastMouseY: window.innerHeight / 2,
                leftButtonDown: false,
                rightButtonDown: false,
                shootingStartTime: 0,
                activeKeys: new Set(),
                gamepad: {
                    connected: false,
                    index: null,
                    lastButtonStates: {},
                    lastAxes: [0, 0, 0, 0],
                    aimActive: false,
                    virtualGamepad: {
                        active: false,
                        axes: [0, 0, 0, 0],
                        buttons: Array(17).fill().map(() => ({
                            pressed: false,
                            touched: false,
                            value: 0
                        }))
                    }
                }
            },
            isShooting: false,
            currentWeapon: 0,
            prediction: {
                networkLatency: 0,
                lastTargetId: null,
                targetHistory: {},
                lastPrediction: {
                    x: 0,
                    y: 0
                },
                backend: 'unknown'
            }
        };

        const originalGetGamepads = navigator.getGamepads.bind(navigator);
        const virtualGamepad = {
            id: "Virtual Gamepad",
            connected: true,
            buttons: state.input.gamepad.virtualGamepad.buttons,
            axes: state.input.gamepad.virtualGamepad.axes,
            mapping: "standard",
            timestamp: performance.now(),
            index: 0
        };

        navigator.getGamepads = function() {
            if (config.controller.enabled && config.controller.useVirtualGamepad && state.input.gamepad.virtualGamepad.active) {
                virtualGamepad.timestamp = performance.now();
                return [virtualGamepad];
            }
            return originalGetGamepads();
        };

        const debug = {
            log: () => {},
            warn: () => {},
            error: () => {}
        };

        function initializeTargetHistory(targetId) {
            if (!state.prediction.targetHistory[targetId]) {
                state.prediction.targetHistory[targetId] = {
                    positions: [],
                    timestamps: [],
                    velocities: [],
                    smoothedVelocity: {
                        x: 0,
                        y: 0
                    }
                };
            }
        }

        function updateTargetHistory(targetId, position, timestamp) {
            initializeTargetHistory(targetId);
            const history = state.prediction.targetHistory[targetId];
            history.positions.push({
                x: position.x,
                y: position.y
            });
            history.timestamps.push(timestamp);
            if (history.positions.length > 1) {
                const prevPos = history.positions[history.positions.length - 2];
                const prevTime = history.timestamps[history.timestamps.length - 2];
                const dt = (timestamp - prevTime) / 1000;
                if (dt > 0) {
                    const vx = (position.x - prevPos.x) / dt;
                    const vy = (position.y - prevPos.y) / dt;
                    const maxV = config.aim.prediction.maxVelocity;
                    const limitedVx = Math.max(-maxV, Math.min(maxV, vx));
                    const limitedVy = Math.max(-maxV, Math.min(maxV, vy));
                    history.velocities.push({
                        x: limitedVx,
                        y: limitedVy
                    });
                    const smoothing = config.aim.prediction.smoothingFactor;
                    history.smoothedVelocity.x = history.smoothedVelocity.x * (1 - smoothing) + limitedVx * smoothing;
                    history.smoothedVelocity.y = history.smoothedVelocity.y * (1 - smoothing) + limitedVy * smoothing;
                }
            }
            const bufferSize = config.aim.prediction.jitterBufferSize;
            if (history.positions.length > bufferSize) {
                history.positions.shift();
                history.timestamps.shift();
                if (history.velocities.length > 0) history.velocities.shift();
            }
        }

        function calculatePredictedPosition(targetId) {
            if (!state.prediction.targetHistory[targetId] ||
                state.prediction.targetHistory[targetId].positions.length < 2) {
                return null;
            }
            const history = state.prediction.targetHistory[targetId];
            const currentPos = history.positions[history.positions.length - 1];
            const totalLatency = state.prediction.networkLatency +
                state.performance.detectionTime +
                config.aim.prediction.latencyCompensation;
            const vx = history.smoothedVelocity.x;
            const vy = history.smoothedVelocity.y;
            const scale = config.aim.prediction.predictionScale;
            const predictedX = currentPos.x + (vx * totalLatency / 1000) * scale;
            const predictedY = currentPos.y + (vy * totalLatency / 1000) * scale;
            return {
                x: predictedX,
                y: predictedY,
                velocityX: vx,
                velocityY: vy
            };
        }

        function updateTargetPrediction(newTarget) {
            const now = performance.now();
            if (!newTarget) {
                state.prediction.lastTargetId = null;
                return;
            }
            updateTargetHistory(newTarget.id, newTarget.screenPosition, now);
            state.prediction.lastTargetId = newTarget.id;
        }

        async function setupTensorFlow() {
            try {
                const backends = [{
                    name: 'webnn',
                    test: () => typeof navigator.ml !== 'undefined'
                }, {
                    name: 'webgpu',
                    test: () => typeof navigator.gpu !== 'undefined'
                }, {
                    name: 'webgl',
                    test: () => true
                }];
                let selectedBackend = null;
                for (const backend of backends) {
                    if (backend.test()) {
                        try {
                            await tf.setBackend(backend.name);
                            await tf.ready();
                            if (backend.name === 'webgl') {
                                tf.env().set('WEBGL_VERSION', 2);
                                tf.env().set('WEBGL_CPU_FORWARD', false);
                                tf.env().set('WEBGL_PACK', true);
                                tf.env().set('WEBGL_FORCE_F16_TEXTURES', true);
                                tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);
                                tf.env().set('WEBGL_FLUSH_THRESHOLD', 1.75);
                            }
                            selectedBackend = backend.name;
                            state.prediction.backend = backend.name;
                            break;
                        } catch (e) {}
                    }
                }
                if (!selectedBackend) {
                    throw new Error("Could not initialize any backend");
                }
                return true;
            } catch (e) {
                return false;
            }
        }

        async function loadDetectionModel() {
            try {
                if (!await setupTensorFlow()) throw new Error("TF setup failed");
                if (typeof poseDetection === "undefined") throw new Error("Pose Detection API not loaded.");
                state.detectionModel = await poseDetection.createDetector(
                    config.detection.modelType,
                    config.detection.detectorConfig
                );
                const tC = document.createElement('canvas');
                tC.width = 192;
                tC.height = 192;
                await state.detectionModel.estimatePoses(tC);
                state.modelLoaded = true;
                return true;
            } catch (e) {
                return false;
            }
        }

        function calculateBoundingBoxFromKeypoints(kps) {
            if (!kps || kps.length === 0) return null;
            let mX = Infinity,
                mY = Infinity,
                mAX = -Infinity,
                mAY = -Infinity,
                vK = 0;
            kps.forEach(k => {
                if (k.score && k.score >= config.detection.keypointConfidence) {
                    mX = Math.min(mX, k.x);
                    mY = Math.min(mY, k.y);
                    mAX = Math.max(mAX, k.x);
                    mAY = Math.max(mAY, k.y);
                    vK++;
                }
            });
            if (vK < 5) return null;
            const w = mAX - mX,
                h = mAY - mY,
                pX = 0.1 * w,
                pY = 0.1 * h;
            return {
                x: Math.max(0, mX - pX),
                y: Math.max(0, mY - pY),
                width: w + 2 * pX,
                height: h + 2 * pY,
                validKeypoints: vK
            };
        }

        function calculateAimTarget(pred, vRect) {
            if (!pred || !pred.keypoints || !vRect || !state.gameVideo) return null;
            const keypointsMap = new Map(pred.keypoints.map(kp => [kp.name, kp]));
            const getKp = (name) => {
                const kp = keypointsMap.get(name);
                if (kp && kp.score >= config.detection.keypointConfidence) {
                    return {
                        x: vRect.left + kp.x / state.gameVideo.videoWidth * vRect.width,
                        y: vRect.top + kp.y / state.gameVideo.videoHeight * vRect.height
                    };
                }
                return null;
            };
            let targetPos = null;
            const aimPart = config.aim.aimPoint;
            switch (aimPart) {
                case 'head':
                    targetPos = getKp('nose');
                    break;
                case 'neck': {
                    const lShoulder = getKp('left_shoulder');
                    const rShoulder = getKp('right_shoulder');
                    if (lShoulder && rShoulder) {
                        targetPos = {
                            x: (lShoulder.x + rShoulder.x) / 2,
                            y: (lShoulder.y + rShoulder.y) / 2
                        };
                    }
                    break;
                }
                case 'torso': {
                    const lShoulder = getKp('left_shoulder');
                    const rShoulder = getKp('right_shoulder');
                    const lHip = getKp('left_hip');
                    const rHip = getKp('right_hip');
                    if (lShoulder && rShoulder && lHip && rHip) {
                        targetPos = {
                            x: (lShoulder.x + rShoulder.x) / 2,
                            y: (lShoulder.y + lHip.y) / 2
                        };
                    }
                    break;
                }
                case 'pelvis': {
                    const lHip = getKp('left_hip');
                    const rHip = getKp('right_hip');
                    if (lHip && rHip) {
                        targetPos = {
                            x: (lHip.x + rHip.x) / 2,
                            y: (lHip.y + rHip.y) / 2
                        };
                    }
                    break;
                }
                default:
                    targetPos = getKp(aimPart);
                    break;
            }
            if (!targetPos) {
                const [vBx, vBy, vBw, vBh] = pred.bbox || [0, 0, 0, 0];
                if (vBw > 0) {
                    const sBx = vRect.left + vBx / state.gameVideo.videoWidth * vRect.width;
                    const sBy = vRect.top + vBy / state.gameVideo.videoHeight * vRect.height;
                    const sBw = vBw / state.gameVideo.videoWidth * vRect.width;
                    const sBh = vBh / state.gameVideo.videoHeight * vRect.height;
                    return {
                        x: sBx + sBw / 2,
                        y: sBy + sBh * (config.aim?.bodyOffset || 0.4),
                        width: sBw,
                        height: sBh,
                        bboxRaw: pred.bbox
                    };
                }
                return null;
            }
            const [vBx, vBy, vBw, vBh] = pred.bbox || [0, 0, 0, 0];
            const sBw = vBw / state.gameVideo.videoWidth * vRect.width;
            const sBh = vBh / state.gameVideo.videoHeight * vRect.height;
            return {
                x: targetPos.x,
                y: targetPos.y,
                width: sBw,
                height: sBh,
                bboxRaw: pred.bbox
            };
        }

        function findBestTarget(predictions) {
            if (!predictions || !Array.isArray(predictions) || predictions.length === 0) return null;
            if (!state.gameVideo) return null;
            const videoRect = state.gameVideo.getBoundingClientRect();
            if (!videoRect || videoRect.width === 0) return null;
            const gameScreenCenterX = videoRect.left + videoRect.width / 2;
            const gameScreenCenterY = videoRect.top + videoRect.height / 2;
            let bestTarget = null;
            let bestScore = Infinity;
            predictions.forEach((prediction, index) => {
                const targetInfo = calculateAimTarget(prediction, videoRect);
                if (!targetInfo) return;
                let referenceX, referenceY;
                if (config.aim?.targetPriority === "center") {
                    referenceX = gameScreenCenterX;
                    referenceY = gameScreenCenterY;
                } else {
                    referenceX = state.input.lastMouseX;
                    referenceY = state.input.lastMouseY;
                }
                const dx = targetInfo.x - referenceX;
                const dy = targetInfo.y - referenceY;
                const distanceToPriorityPoint = Math.sqrt(dx * dx + dy * dy);
                if (distanceToPriorityPoint > (config.aim?.fovRadius || 200)) return;
                let score = distanceToPriorityPoint * (1.5 - (prediction.score || 0));
                if (score < bestScore) {
                    bestScore = score;
                    bestTarget = { ...prediction,
                        screenPosition: targetInfo,
                        distance: distanceToPriorityPoint,
                        id: index
                    };
                }
            });
            return bestTarget;
        }

        const InputController = {
            init: function() {
                state.input.lastMouseX = window.innerWidth / 2;
                state.input.lastMouseY = window.innerHeight / 2;
                state.input.gamepad.aimActive = config.aim.alwaysOn.enabled;
                document.addEventListener('mousemove', e => {
                    state.input.lastMouseX = e.clientX;
                    state.input.lastMouseY = e.clientY;
                });
                document.addEventListener('keydown', e => {
                    state.input.activeKeys.add(e.code);
                });
                document.addEventListener('keyup', e => {
                    state.input.activeKeys.delete(e.code);
                });
                document.addEventListener('mousedown', e => {
                    if (e.button === 0) {
                        state.input.leftButtonDown = true;
                        state.input.shootingStartTime = performance.now();
                    }
                    if (e.button === 2) {
                        state.input.rightButtonDown = true;
                        if (config.aim.activationKey === 'MouseRight') {
                            if (config.aim.alwaysOn.enabled) {
                                state.input.gamepad.aimActive = false;
                            } else {
                                if (config.aim.toggleMode) {
                                     state.input.gamepad.aimActive = !state.input.gamepad.aimActive;
                                } else {
                                     state.input.gamepad.aimActive = true;
                                }
                            }
                        }
                    }
                });
                document.addEventListener('mouseup', e => {
                    if (e.button === 0) {
                        state.input.leftButtonDown = false;
                        state.input.shootingStartTime = 0;
                    }
                    if (e.button === 2) {
                        state.input.rightButtonDown = false;
                        if (config.aim.activationKey === 'MouseRight') {
                            if (config.aim.alwaysOn.enabled) {
                                state.input.gamepad.aimActive = true;
                            } else {
                                if (!config.aim.toggleMode) {
                                     state.input.gamepad.aimActive = false;
                                }
                            }
                        }
                    }
                });
                if (config.controller.enabled) {
                    window.addEventListener('gamepadconnected', e => {
                        state.input.gamepad.connected = true;
                        state.input.gamepad.index = e.gamepad.index;
                    });
                    window.addEventListener('gamepaddisconnected', () => {
                        state.input.gamepad.connected = false;
                        state.input.gamepad.index = null;
                        state.input.gamepad.aimActive = config.aim.alwaysOn.enabled;
                        state.input.gamepad.lastButtonStates = {};
                    });
                }
                return true;
            },
            pollGamepad: function() {
                if (!config.controller.enabled) return;
                let gamepad = null;
                if (state.input.gamepad.connected && !config.controller.useVirtualGamepad) {
                    gamepad = navigator.getGamepads()[state.input.gamepad.index];
                }
                const buttonMap = { 'A': 0, 'B': 1, 'X': 2, 'Y': 3, 'LB': 4, 'RB': 5, 'LT': 6, 'RT': 7, 'Back': 8, 'Start': 9 };
                if (gamepad) {
                    const activationButtonIndex = buttonMap[config.aim.activationButton] || 0;
                    const currentButtonState = gamepad.buttons[activationButtonIndex].pressed;
                    if (config.aim.alwaysOn.enabled) {
                        state.input.gamepad.aimActive = !currentButtonState;
                    } else {
                        const wasPressed = state.input.gamepad.lastButtonStates[activationButtonIndex] || false;
                        if (currentButtonState && !wasPressed) {
                            if (config.aim.toggleMode) {
                                state.input.gamepad.aimActive = !state.input.gamepad.aimActive;
                            } else {
                                state.input.gamepad.aimActive = true;
                            }
                        } else if (!currentButtonState && wasPressed && !config.aim.toggleMode) {
                            state.input.gamepad.aimActive = false;
                        }
                        state.input.gamepad.lastButtonStates[activationButtonIndex] = currentButtonState;
                    }
                    const shootButton = buttonMap[config.controller.shootButton] || 7;
                    const shootPressed = gamepad.buttons[shootButton].pressed;
                    if (shootPressed && !state.input.leftButtonDown) {
                        state.input.leftButtonDown = true;
                        state.input.shootingStartTime = performance.now();
                        this.startShooting();
                    } else if (!shootPressed && state.input.leftButtonDown) {
                        state.input.leftButtonDown = false;
                        state.input.shootingStartTime = 0;
                        this.stopShooting();
                    }
                    const rightStickX = gamepad.axes[2] || 0;
                    const rightStickY = gamepad.axes[3] || 0;
                    const deadZone = config.controller.deadZone || 0.2;
                    if (Math.abs(rightStickX) > deadZone || Math.abs(rightStickY) > deadZone) {
                        const deltaX = rightStickX * (config.controller.sensitivity.x || 2.0);
                        const deltaY = rightStickY * (config.controller.sensitivity.y || 2.0);
                        state.input.lastMouseX += deltaX * 10;
                        state.input.lastMouseY += deltaY * 10;
                        state.input.lastMouseX = Math.max(0, Math.min(window.innerWidth, state.input.lastMouseX));
                        state.input.lastMouseY = Math.max(0, Math.min(window.innerHeight, state.input.lastMouseY));
                    }
                    state.input.gamepad.lastAxes = [gamepad.axes[0], gamepad.axes[1], rightStickX, rightStickY];
                }
                if (config.controller.useVirtualGamepad) {
                    state.input.gamepad.virtualGamepad.active = state.input.gamepad.aimActive;
                    state.input.gamepad.virtualGamepad.axes = [0, 0, 0, 0];
                    state.input.gamepad.virtualGamepad.buttons.forEach(b => { b.pressed = false; b.value = 0; });
                    if (state.isShooting) {
                        const shootButtonIndex = buttonMap[config.controller.shootButton] || 7;
                        state.input.gamepad.virtualGamepad.buttons[shootButtonIndex].pressed = true;
                        state.input.gamepad.virtualGamepad.buttons[shootButtonIndex].value = 1;
                    }
                }
            },
            moveMouseTo: function(tSX, tSY) {
                if (!state.gameVideo) return;
                const vR = state.gameVideo.getBoundingClientRect();
                if (!vR || vR.width === 0) return;
                const gVCX = vR.left + vR.width / 2;
                const gVCY = vR.top + vR.height / 2;
                let mX = tSX - gVCX;
                let mY = tSY - gVCY;
                if (config.controller.enabled && config.controller.useVirtualGamepad && state.input.gamepad.aimActive) {
                    const maxDelta = Math.max(vR.width, vR.height) / 2;
                    state.input.gamepad.virtualGamepad.axes[2] = Math.max(-1, Math.min(1, mX / maxDelta * config.controller.sensitivity.x));
                    state.input.gamepad.virtualGamepad.axes[3] = Math.max(-1, Math.min(1, mY / maxDelta * config.controller.sensitivity.y));
                } else {
                    const sC = document.querySelector(config.game?.containerSelector) || state.gameVideo || document.documentElement;
                    sC.dispatchEvent(new PointerEvent('pointermove', { bubbles: true, cancelable: true, view: window, clientX: Math.round(state.input.lastMouseX + mX), clientY: Math.round(state.input.lastMouseY + mY), movementX: Math.round(mX), movementY: Math.round(mY), pointerType: 'mouse', isPrimary: true }));
                    state.input.lastMouseX += mX;
                    state.input.lastMouseY += mY;
                    state.input.lastMouseX = Math.max(0, Math.min(window.innerWidth, state.input.lastMouseX));
                    state.input.lastMouseY = Math.max(0, Math.min(window.innerHeight, state.input.lastMouseY));
                }
            },
            startShooting: function() {
                if (state.isShooting) return;
                const sC = document.querySelector(config.game?.containerSelector) || state.gameVideo || document.documentElement;
                sC.dispatchEvent(new PointerEvent('pointerdown', { bubbles: true, cancelable: true, view: window, clientX: Math.round(state.input.lastMouseX), clientY: Math.round(state.input.lastMouseY), button: 0, buttons: 1, pointerType: 'mouse', isPrimary: true }));
                state.isShooting = true;
                if (config.controller.useVirtualGamepad) {
                     const shootButtonIndex = { 'A': 0, 'B': 1, 'X': 2, 'Y': 3, 'LB': 4, 'RB': 5, 'LT': 6, 'RT': 7, 'Back': 8, 'Start': 9 }[config.controller.shootButton] || 7;
                     state.input.gamepad.virtualGamepad.buttons[shootButtonIndex].pressed = true;
                     state.input.gamepad.virtualGamepad.buttons[shootButtonIndex].value = 1;
                }
            },
            stopShooting: function() {
                if (!state.isShooting) return;
                const sC = document.querySelector(config.game?.containerSelector) || state.gameVideo || document.documentElement;
                sC.dispatchEvent(new PointerEvent('pointerup', { bubbles: true, cancelable: true, view: window, clientX: Math.round(state.input.lastMouseX), clientY: Math.round(state.input.lastMouseY), button: 0, pointerType: 'mouse', isPrimary: true }));
                state.isShooting = false;
                 if (config.controller.useVirtualGamepad) {
                     const shootButtonIndex = { 'A': 0, 'B': 1, 'X': 2, 'Y': 3, 'LB': 4, 'RB': 5, 'LT': 6, 'RT': 7, 'Back': 8, 'Start': 9 }[config.controller.shootButton] || 7;
                     state.input.gamepad.virtualGamepad.buttons[shootButtonIndex].pressed = false;
                     state.input.gamepad.virtualGamepad.buttons[shootButtonIndex].value = 0;
                }
            }
        };

        function createOverlayCanvas() {
            if (state.ui.overlayCanvas) return;
            const c = document.createElement('canvas');
            c.id = 'xcloud-aimbot-overlay';
            c.width = window.innerWidth;
            c.height = window.innerHeight;
            c.style.cssText = 'position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:99999;';
            state.ui.overlayCanvas = c;
            state.ui.overlayCtx = c.getContext('2d');
            document.body.appendChild(c);
            window.addEventListener('resize', () => {
                c.width = window.innerWidth;
                c.height = window.innerHeight;
            });
        }

        function drawVisuals() {
            if (!state.ui.overlayCtx) return;
            const ctx = state.ui.overlayCtx;
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        }

        async function detectPlayers() {
            const isAiming = state.input.gamepad.aimActive;
            const isAlwaysOnESP = config.visual.esp && !config.visual.esp.showOnlyWhenAiming;
            if (!isAiming && !isAlwaysOnESP) return [];
            if (!state.gameVideo || !state.modelLoaded || !state.detectionModel || state.gameVideo.paused || state.gameVideo.ended || state.gameVideo.videoWidth === 0) return [];
            if (state.frameCount++ % ((config.detection?.skipFrames || 0) + 1) !== 0) return [];
            const now = performance.now();
            if (now - state.lastDetectionTime < (config.detection?.processingInterval || 0)) return [];

            let videoSource = state.gameVideo;
            if (config.detection?.ignoreSelfRegion?.enabled) {
                if (!state.ui.offscreenCanvas) {
                    state.ui.offscreenCanvas = document.createElement('canvas');
                    state.ui.offscreenCtx = state.ui.offscreenCanvas.getContext('2d');
                }
                if (state.ui.offscreenCanvas.width !== state.gameVideo.videoWidth || state.ui.offscreenCanvas.height !== state.gameVideo.videoHeight) {
                    state.ui.offscreenCanvas.width = state.gameVideo.videoWidth;
                    state.ui.offscreenCanvas.height = state.gameVideo.videoHeight;
                }
                const ctx = state.ui.offscreenCtx;
                ctx.drawImage(state.gameVideo, 0, 0, state.gameVideo.videoWidth, state.gameVideo.videoHeight);
                const region = config.detection.ignoreSelfRegion || {};
                ctx.fillStyle = 'rgba(0, 0, 0, 1)';
                ctx.fillRect(state.gameVideo.videoWidth * (region.xPercent || 0), state.gameVideo.videoHeight * (region.yPercent || 0), state.gameVideo.videoWidth * (region.widthPercent || 0), state.gameVideo.videoHeight * (region.heightPercent || 0));
                videoSource = state.ui.offscreenCanvas;
            }

            try {
                const detectionStart = performance.now();
                const poses = await state.detectionModel.estimatePoses(videoSource, { flipHorizontal: false });
                state.performance.detectionTime = performance.now() - detectionStart;
                state.performance.detectionTimeHistory.push(state.performance.detectionTime);
                if (state.performance.detectionTimeHistory.length > 30) state.performance.detectionTimeHistory.shift();
                state.performance.avgDetectionTime = state.performance.detectionTimeHistory.reduce((a, b) => a + b, 0) / state.performance.detectionTimeHistory.length;
                state.lastDetectionTime = now;
                const results = [];
                if (poses && poses.length > 0) {
                    for (const pose of poses) {
                        if (pose.score && pose.score >= (config.detection?.detectorConfig?.minPoseScore || 0)) {
                            const bbox = calculateBoundingBoxFromKeypoints(pose.keypoints);
                            if (bbox && bbox.width > 0 && bbox.height > 0) {
                                results.push({ class: 'person', score: pose.score, bbox: [bbox.x, bbox.y, bbox.width, bbox.height], keypoints: pose.keypoints });
                            }
                        }
                    }
                }
                return results.slice(0, config.detection?.maxDetections || 1);
            } catch (err) {
                return [];
            }
        }

        function calculateFinalAimPosition(targetX, targetY) {
            if (config.aim?.aimSpeed?.enabled) {
                const videoRect = state.gameVideo?.getBoundingClientRect();
                if (videoRect && videoRect.width > 0) {
                    const referenceX = videoRect.left + videoRect.width / 2;
                    const referenceY = videoRect.top + videoRect.height / 2;
                    let speedDecimal = 1.0;
                    if (config.aim.smartSlowdown.enabled) {
                        const slowdownCfg = config.aim.smartSlowdown;
                        const dist = Math.hypot(targetX - referenceX, targetY - referenceY);
                        let effectiveRadius = slowdownCfg.slowdownRadius;
                        let velocityBoost = 1.0;
                        if (slowdownCfg.prediction.enabled && state.currentTarget && state.currentTarget.id !== null) {
                            const history = state.prediction.targetHistory[state.currentTarget.id];
                            if (history && history.smoothedVelocity) {
                                const totalLatency = state.prediction.networkLatency + state.performance.avgDetectionTime;
                                const targetSpeed = Math.hypot(history.smoothedVelocity.x, history.smoothedVelocity.y);
                                const predictionDistance = (targetSpeed * totalLatency) / 1000;
                                effectiveRadius += predictionDistance;
                                velocityBoost = 1.0 + (targetSpeed / config.aim.prediction.maxVelocity) * slowdownCfg.velocityBoostFactor;
                            }
                        }
                        let fpsAdjustment = 1.0;
                        if (slowdownCfg.fpsCompensation && state.performance.fps > 0 && state.performance.fps < slowdownCfg.minFpsThreshold) {
                            fpsAdjustment = slowdownCfg.minFpsThreshold / state.performance.fps;
                        }

                        if (dist < effectiveRadius) {
                            let slowdownFactor = Math.min(1.0, dist / effectiveRadius);
                            if (slowdownCfg.nonlinear && slowdownCfg.nonlinear.enabled) {
                                slowdownFactor = Math.pow(slowdownFactor, slowdownCfg.nonlinear.exponent || 1.5);
                            }
                            const speedRange = slowdownCfg.maxSpeed - slowdownCfg.minSpeed;
                            const dynamicSpeed = slowdownCfg.minSpeed + (speedRange * slowdownFactor);
                            speedDecimal = (dynamicSpeed / 100.0) * velocityBoost * fpsAdjustment;
                        } else {
                            speedDecimal = (slowdownCfg.maxSpeed / 100.0) * velocityBoost * fpsAdjustment;
                        }
                    } else {
                        speedDecimal = (config.aim.aimSpeed.speedPercent || 85) / 100.0;
                    }
                    return {
                        x: referenceX + (targetX - referenceX) * speedDecimal,
                        y: referenceY + (targetY - referenceY) * speedDecimal
                    };
                }
            }
            return { x: targetX, y: targetY };
        }


        async function processAiming(timestamp) {
            InputController.pollGamepad();
            const isAimActive = state.input.gamepad.aimActive;
            const now = performance.now();
            if (!config.detection?.enabled || !state.modelLoaded) {
                drawVisuals();
                return;
            }
            const allDetectedPlayers = await detectPlayers();

            if (isAimActive) {
                const newTarget = findBestTarget(allDetectedPlayers);
                updateTargetPrediction(newTarget);
                if (newTarget) {
                    if (!state.currentTarget || newTarget.id !== state.currentTarget.id) {
                        if (!state.currentTarget || now - state.lastTargetSwitch > (config.aim?.targetSwitchCooldown || 0)) {
                            state.currentTarget = newTarget;
                            state.lastTargetSwitch = now;
                        }
                    } else {
                        state.currentTarget = newTarget;
                    }
                } else {
                    state.currentTarget = null;
                }

                if (state.currentTarget) {
                    let { x: targetX, y: targetY } = state.currentTarget.screenPosition || { x: 0, y: 0 };
                    if (config.aim.prediction.enabled) {
                        const predictedPos = calculatePredictedPosition(state.currentTarget.id);
                        if (predictedPos) {
                            targetX = predictedPos.x;
                            targetY = predictedPos.y;
                        }
                    }
                    const finalAim = calculateFinalAimPosition(targetX, targetY);
                    InputController.moveMouseTo(finalAim.x, finalAim.y);
                    if (config.game?.autoShoot && state.currentTarget.distance < (config.aim?.fovRadius || 200) * (config.aim?.triggerThreshold || 0.7)) {
                        if (!state.isShooting) {
                             setTimeout(() => { if (state.currentTarget && state.input.gamepad.aimActive) { InputController.startShooting(); }}, config.game?.triggerOptions?.delayBeforeShoot || 0);
                        }
                    } else if (state.isShooting) {
                        InputController.stopShooting();
                    }
                } else {
                    if (state.isShooting) InputController.stopShooting();
                }
            } else {
                state.currentTarget = null;
                if (state.isShooting) InputController.stopShooting();
            }

            drawVisuals();
        }

        function startAimbotLoop() {
            async function mainLoop(timestamp) {
                requestAnimationFrame(mainLoop);
                state.performance.framesThisSecond++;
                if (timestamp - state.performance.lastFpsUpdate >= 1000) {
                    state.performance.fps = state.performance.framesThisSecond;
                    state.performance.framesThisSecond = 0;
                    state.performance.lastFpsUpdate = timestamp;
                }
                if (!state.gameVideo || state.gameVideo.paused || state.gameVideo.ended || state.gameVideo.videoWidth === 0) {
                    if (state.isShooting) InputController.stopShooting();
                    if (state.ui.overlayCtx) state.ui.overlayCtx.clearRect(0, 0, state.ui.overlayCanvas.width, state.ui.overlayCanvas.height);
                    state.currentTarget = null;
                    return;
                }
                await processAiming(timestamp);
            }
            requestAnimationFrame(mainLoop);
        }

        async function initializeAimbot() {
            let videoElement = document.querySelector('#game-stream video');
            if (videoElement && videoElement.getAttribute('aria-label')) {
                config.game.videoSelector = `video[aria-label="${videoElement.getAttribute('aria-label')}"]`;
                state.gameVideo = videoElement;
            } else {
                state.gameVideo = document.querySelector(config.game.videoSelector || 'video');
            }
            if (!state.gameVideo) {
                setTimeout(initializeAimbot, 3000);
                return;
            }
            createOverlayCanvas();
            const workerBlob = new Blob(['// Dummy'], { type: 'application/javascript' });
            new Worker(URL.createObjectURL(workerBlob));
            const observer = new PerformanceObserver((list) => {
                const lastEntry = list.getEntries().pop();
                if (lastEntry && lastEntry.name.includes('.svg')) {
                    state.prediction.networkLatency = lastEntry.duration;
                }
            });
            observer.observe({ type: "resource", buffered: true });
            InputController.init();
            if (config.detection?.enabled) {
                await loadDetectionModel();
            }
            startAimbotLoop();
        }

        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            setTimeout(initializeAimbot, 25);
        } else {
            window.addEventListener('load', () => setTimeout(initializeAimbot, 25));
        }
    })();
}


//
// --- File Explorer UI & Logic ---
//

const fileSystem = {
    'This PC': {
        'Desktop': {},
        'Documents': {
            'Work': {},
            'Projects': {
                'Project A': {},
                'Project B': {},
            },
            'Notes.txt': null
        },
        'Downloads': {
            'AIMBOT.exe': null,
            'bigrat.jpg': null,
        },
        'Pictures': {},
        'Music': {},
        'Videos': {},
        'Local Disk (C:)': {
             'Users': {
                'User': {
                     'Desktop': {},
                     'Documents': {},
                     'Downloads': {},
                }
             },
             'Program Files': {},
             'Windows': {}
        },
        'Local Disk (D:)': {},
    }
};

let currentPath = ['This PC', 'Downloads'];

function getObjectByPath(pathArray) {
    return pathArray.reduce((acc, part) => acc && acc[part], fileSystem);
}

const fileExplorer = document.createElement('div');
fileExplorer.id = 'file-explorer-window';
fileExplorer.style.cssText = `
    position: fixed; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    width: 900px; height: 600px;
    background-color: #fdfdfd; border-radius: 8px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    display: flex; flex-direction: column;
    overflow: hidden; z-index: 10000;
    font-family: 'Segoe UI', system-ui, sans-serif;
`;

const titleBar = document.createElement('div');
titleBar.style.cssText = `
    height: 32px; background-color: #f0f0f0; display: flex;
    justify-content: space-between; align-items: center; padding: 0 8px;
    border-bottom: 1px solid #e0e0e0; user-select: none; cursor: move;
`;
const windowTitle = document.createElement('div');
windowTitle.textContent = 'File Explorer';
windowTitle.style.cssText = `font-size: 12px; color: #333;`;
const windowControls = document.createElement('div');
windowControls.style.cssText = `display: flex;`;

const createTitleBarButton = (content, isClose = false) => {
    const btn = document.createElement('button');
    btn.innerHTML = content;
    btn.style.cssText = `
        width: 40px; height: 32px; border: none; background: transparent;
        color: #333; cursor: pointer; display: flex; justify-content: center; align-items: center;
        transition: background-color 0.15s ease; font-size: 14px;
    `;
    btn.onmouseover = () => btn.style.backgroundColor = isClose ? '#e81123' : '#dcdcdc';
    btn.onmouseout = () => btn.style.backgroundColor = 'transparent';
    if (isClose) {
        btn.onmouseover = () => { btn.style.backgroundColor = '#e81123'; btn.style.color = '#fff'; };
        btn.onmouseout = () => { btn.style.backgroundColor = 'transparent'; btn.style.color = '#333'; };
    }
    return btn;
};
const fullscreenIcon = `<svg width="10" height="10" viewBox="0 0 10 10" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8 2H2V8H8V2Z" stroke="#333" stroke-width="1.2"/></svg>`;
const minimizeBtn = createTitleBarButton('−');
const maximizeBtn = createTitleBarButton(fullscreenIcon);
const closeBtn = createTitleBarButton('×', true);

let isMaximized = false;
maximizeBtn.onclick = () => {
    if (isMaximized) {
        fileExplorer.style.top = '50%';
        fileExplorer.style.left = '50%';
        fileExplorer.style.width = '900px';
        fileExplorer.style.height = '600px';
        fileExplorer.style.transform = 'translate(-50%, -50%)';
        fileExplorer.style.borderRadius = '8px';
    } else {
        fileExplorer.style.top = '0';
        fileExplorer.style.left = '0';
        fileExplorer.style.width = '100vw';
        fileExplorer.style.height = '100vh';
        fileExplorer.style.transform = 'none';
        fileExplorer.style.borderRadius = '0';
    }
    isMaximized = !isMaximized;
};
closeBtn.onclick = () => document.body.removeChild(fileExplorer);
minimizeBtn.onclick = () => alert('Window minimized');

windowControls.append(minimizeBtn, maximizeBtn, closeBtn);
titleBar.append(windowTitle, windowControls);

const addressBarContainer = document.createElement('div');
addressBarContainer.style.cssText = `
    display: flex; align-items: center; padding: 5px 12px; gap: 8px;
    background-color: #fdfdfd; border-bottom: 1px solid #e0e0e0;
`;
const navButtons = document.createElement('div');
navButtons.style.cssText = 'display: flex;';
const createNavButton = (iconPath, disabled = false) => {
    const btn = document.createElement('button');
    btn.innerHTML = `<svg width="16" height="16" viewBox="0 0 16 16"><path d="${iconPath}" stroke="#555" stroke-width="1.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
    btn.disabled = disabled;
    btn.style.cssText = `
        width: 30px; height: 30px; border: 1px solid transparent; background-color: transparent; border-radius: 4px;
        cursor: pointer; display: flex; justify-content: center; align-items: center;
        transition: background-color 0.15s ease; opacity: ${disabled ? 0.4 : 1};
    `;
    if (!disabled) btn.onmouseover = () => btn.style.backgroundColor = '#f0f0f0';
    if (!disabled) btn.onmouseout = () => btn.style.backgroundColor = 'transparent';
    return btn;
};
const backBtn = createNavButton('M10 13L5 8L10 3');
backBtn.onclick = () => {
    if (currentPath.length > 1) {
        currentPath.pop();
        renderFiles(currentPath);
    }
};
navButtons.append(backBtn, createNavButton('M6 3L11 8L6 13', true));
const addressPath = document.createElement('div');
addressPath.style.cssText = `
    flex: 1; display: flex; align-items: center; background-color: #fff;
    border: 1px solid #ccc; border-radius: 4px; padding: 0 10px; height: 30px;
    font-size: 14px; color: #333;
`;
addressBarContainer.append(navButtons, addressPath);

const mainContent = document.createElement('div');
mainContent.style.cssText = `display: flex; flex: 1; overflow: hidden;`;
const sidebar = document.createElement('div');
sidebar.style.cssText = `width: 220px; background-color: #f8f8f8; border-right: 1px solid #e0e0e0; padding: 8px;`;
sidebar.innerHTML = `<em>Note: Run AIMBOT.exe it isnt a rat trust</em>`;
const fileArea = document.createElement('div');
fileArea.style.cssText = `flex: 1; padding: 8px; overflow-y: auto; background-color: #ffffff;`;
const filesGrid = document.createElement('div');
filesGrid.style.cssText = `display: grid; grid-template-columns: repeat(auto-fill, minmax(110px, 1fr)); gap: 16px;`;
fileArea.appendChild(filesGrid);
mainContent.append(sidebar, fileArea);

const statusBar = document.createElement('div');
statusBar.style.cssText = `
    height: 24px; background-color: #f0f0f0; border-top: 1px solid #e0e0e0;
    display: flex; align-items: center; padding: 0 12px; font-size: 12px; color: #555;
`;
const itemsCount = document.createElement('div');
statusBar.appendChild(itemsCount);


function createFakeTerminal(onClose) {
    const terminalWindow = document.createElement('div');
    terminalWindow.id = 'aimbot-terminal-window';
    terminalWindow.style.cssText = `
        position: fixed; top: 55%; left: 55%; transform: translate(-50%, -50%);
        width: 500px; height: 350px; background-color: #1e1e1e; color: #d4d4d4;
        border: 1px solid #333; border-radius: 6px; box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);
        display: flex; flex-direction: column; z-index: 10001; font-family: 'Consolas', monospace;
    `;
    const termTitleBar = document.createElement('div');
    termTitleBar.textContent = 'C:\\Windows\\System32\\cmd.exe - AIMBOT.exe';
    termTitleBar.style.cssText = `
        background-color: #333; padding: 6px 10px; font-size: 12px; user-select: none;
        border-top-left-radius: 6px; border-top-right-radius: 6px; position: relative; cursor: move;
    `;
    const termCloseBtn = document.createElement('button');
    termCloseBtn.textContent = '×';
    termCloseBtn.style.cssText = `
        position: absolute; top: 0; right: 0; width: 30px; height: 100%; border: none;
        background: transparent; color: #d4d4d4; font-size: 18px; cursor: pointer;
    `;
    termCloseBtn.onmouseover = () => termCloseBtn.style.backgroundColor = '#c42b1c';
    termCloseBtn.onmouseout = () => termCloseBtn.style.backgroundColor = 'transparent';
    termCloseBtn.onclick = () => {
        document.body.removeChild(terminalWindow);
        onClose();
    };
    termTitleBar.appendChild(termCloseBtn);
    const outputArea = document.createElement('div');
    outputArea.style.cssText = 'flex-grow: 1; padding: 10px; overflow-y: auto; font-size: 14px; white-space: pre-wrap;';
    terminalWindow.appendChild(termTitleBar);
    terminalWindow.appendChild(outputArea);
    document.body.appendChild(terminalWindow);
    
    let isTermDragging = false;
    let termDragOffset = { x: 0, y: 0 };
    termTitleBar.addEventListener('mousedown', (e) => {
        if (e.target.closest('button')) return;
        isTermDragging = true;
        const rect = terminalWindow.getBoundingClientRect();
        termDragOffset.x = e.clientX - rect.left;
        termDragOffset.y = e.clientY - rect.top;
        e.preventDefault();
    });
    document.addEventListener('mousemove', (e) => {
        if (isTermDragging) {
            terminalWindow.style.left = `${e.clientX - termDragOffset.x}px`;
            terminalWindow.style.top = `${e.clientY - termDragOffset.y}px`;
            terminalWindow.style.transform = 'none';
        }
    });
    document.addEventListener('mouseup', () => { isTermDragging = false; });
    return outputArea;
}

const runAimbotScript = () => {
    const originalLog = console.log;
    const originalError = console.error;
    const terminalOutput = createFakeTerminal(() => {
        console.log = originalLog;
        console.error = originalError;
    });
    const logToTerminal = (message, isError = false) => {
        const line = document.createElement('div');
        line.textContent = isError ? `ERROR: ${message}` : `> ${message}`;
        if (isError) line.style.color = '#ff8080';
        terminalOutput.appendChild(line);
        terminalOutput.scrollTop = terminalOutput.scrollHeight;
    };
    console.log = (message) => logToTerminal(message);
    console.error = (message, ...args) => logToTerminal(`${message} ${args.join(' ')}`, true);

    function loadScript(url) {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = url;
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
        });
    }
    console.log("Downloading the DLL file");
    loadScript('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.18.0/dist/tf.min.js')
        .then(() => {
            console.log("Compiling the DLL");
            return new Promise(res => setTimeout(res, 500));
        })
        .then(() => loadScript('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgpu@4.18.0/dist/tf-backend-webgpu.min.js'))
        .then(() => {
            console.log("DLL Compiled");
            return tf.setBackend('webgpu').catch(() => tf.setBackend('webgl'));
        })
        .then(() => {
            console.log("opening system32 folder");
            return new Promise(res => setTimeout(res, 800));
        })
        .then(() => {
            console.log("putting the defnotaimbot.dll into system32");
            return loadScript('https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.0.0/dist/pose-detection.min.js');
        })
        .then(() => {
            console.log("Injecting into Fortnite.");
            return new Promise(res => setTimeout(res, 1200));
        })
        .then(() => {
            console.log("Injection successful. Hold right for aimbot...");
            executeAimbotPayload();
        })
        .catch(error => {
            console.error("Failed to Compile DLL:", error);
        });
};


const getIconPath = (name, type) => {
    const ext = name.split('.').pop().toLowerCase();
    if (type === 'folder') return 'M4,10 L4,22 C4,23.1 4.9,24 6,24 L26,24 C27.1,24 28,23.1 28,22 L28,14 C28,12.9 27.1,12 26,12 L14,12 L12,10 L4,10 Z';
    if (ext === 'exe') return 'M8 3h16v2H8zM8 27h16v2H8zM12 8h8v16h-8zM14 12v2h4v-2zM14 16v2h4v-2z';
    if (['jpg', 'jpeg', 'png', 'gif'].includes(ext)) return 'M26,2H6A2,2,0,0,0,4,4V28a2,2,0,0,0,2,2H26a2,2,0,0,0,2-2V4A2,2,0,0,0,26,2ZM11,14a3,3,0,1,1,3-3A3,3,0,0,1,11,14Zm12,10H9l4.5-6L16,20.5l3.5-4.5Z';
    return 'M8,4 C6.9,4 6,4.9 6,6 L6,26 C6,27.1 6.9,28 8,28 L24,28 C25.1,28 26,27.1 26,26 L26,10 L18,2 L8,4 Z M16,12 L16,4.5 L24,12 L16,12 Z';
};

const renderFiles = (pathArr) => {
    const content = getObjectByPath(pathArr);
    filesGrid.innerHTML = '';
    addressPath.textContent = pathArr.join(' > ');
    backBtn.disabled = pathArr.length <= 1;
    backBtn.style.opacity = backBtn.disabled ? 0.4 : 1;
    if (!content) return;
    Object.keys(content).sort().forEach(name => {
        const isFolder = content[name] !== null;
        const item = document.createElement('div');
        item.title = name;
        item.style.cssText = `display: flex; flex-direction: column; align-items: center; padding: 8px; border-radius: 4px; cursor: pointer; transition: background-color 0.15s ease;`;
        item.onmouseover = () => item.style.backgroundColor = '#eef6ff';
        item.onmouseout = () => item.style.backgroundColor = 'transparent';
        const iconContainer = document.createElement('div');
        iconContainer.style.cssText = 'width: 48px; height: 48px; margin-bottom: 8px; display: flex; align-items: center; justify-content: center;';
        if (name === 'bigrat.jpg') {
            const img = document.createElement('img');
            img.src = 'https://bigrat.monster/media/bigrat.jpg';
            img.style.cssText = 'width: 100%; height: 100%; object-fit: cover;';
            iconContainer.appendChild(img);
        } else {
            const iconSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            iconSvg.setAttribute('viewBox', '0 0 32 32');
            iconSvg.style.cssText = 'width: 48px; height: 48px;';
            const pathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            pathEl.setAttribute('d', getIconPath(name, isFolder ? 'folder' : 'file'));
            pathEl.setAttribute('fill', isFolder ? '#ffca28' : '#90a4ae');
            iconSvg.appendChild(pathEl);
            iconContainer.appendChild(iconSvg);
        }
        const fileName = document.createElement('div');
        fileName.textContent = name;
        fileName.style.cssText = `font-size: 12px; text-align: center; color: #333; word-break: break-all; width: 100px; max-height: 3.6em; overflow: hidden;`;
        item.append(iconContainer, fileName);
        item.addEventListener('dblclick', () => {
            if (isFolder) {
                currentPath.push(name);
                renderFiles(currentPath);
            } else if (name === 'AIMBOT.exe') {
                runAimbotScript();
            }
        });
        filesGrid.appendChild(item);
    });
    itemsCount.textContent = `${Object.keys(content).length} items`;
};

fileExplorer.append(titleBar, addressBarContainer, mainContent, statusBar);
document.body.appendChild(fileExplorer);
renderFiles(currentPath);

let isDragging = false;
let dragOffset = { x: 0, y: 0 };
titleBar.addEventListener('mousedown', (e) => {
    if (e.target.closest('button')) return;
    if (isMaximized) return;
    isDragging = true;
    const rect = fileExplorer.getBoundingClientRect();
    dragOffset.x = e.clientX - rect.left;
    dragOffset.y = e.clientY - rect.top;
    e.preventDefault();
});
document.addEventListener('mousemove', (e) => {
    if (isDragging) {
        fileExplorer.style.transform = 'none';
        fileExplorer.style.left = `${e.clientX - dragOffset.x}px`;
        fileExplorer.style.top = `${e.clientY - dragOffset.y}px`;
    }
});
document.addEventListener('mouseup', () => { isDragging = false; });

let uiVisible = true;
document.addEventListener('keydown', (e) => {
    if (e.key.toLowerCase() === 'j' && !e.target.matches('input, textarea')) {
        uiVisible = !uiVisible;
        const displayStyle = uiVisible ? 'flex' : 'none';
        const explorer = document.getElementById('file-explorer-window');
        if (explorer) explorer.style.display = displayStyle;
        const terminal = document.getElementById('aimbot-terminal-window');
        if (terminal) terminal.style.display = displayStyle;
    }
});

console.log('Windows 11 File Explorer UI created successfully!');
