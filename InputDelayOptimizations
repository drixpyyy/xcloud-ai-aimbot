// fixed it not even fucking working

(function() {
    'use strict';

    // ========================================================================
    // CONFIGURATION (v3.0 Base)
    // ========================================================================
    const CONFIG = {
        autoDetection: {
            enabled: true,
            updateInterval: 2000,
            statsSelector: '.StreamStats-module__container___UPibv', 
            fallbackLatency: 75,
            minLatency: 10,
            maxLatency: 300
        },

        prediction: {
            model: 'adaptive', // 'linear', 'quadratic', 'kalman', 'adaptive'
            jitterBuffer: 15,
            adaptiveScale: 1.2, 
            confidenceThreshold: 0.7,
            // Safety: Only move if velocity is above this
            movementThreshold: 0.5 
        },

        smoothing: {
            enabled: true,
            velocityAlpha: 0.3, 
            accelerationAlpha: 0.25,
            adaptiveSmoothing: true,
            minAlpha: 0.15,
            maxAlpha: 0.6
        },

        jitter: {
            enabled: true,
            detectionWindow: 10,
            threshold: 5,
            dampingFactor: 0.5,
            adaptiveDamping: true
        },

        input: {
            usePrecisionDelta: true,
            frameSync: true,
            pointerPressure: 0.5
        },

        visual: {
            enabled: true,
            showOverlay: true,
            showMetrics: true,
            position: 'top-right',
            opacity: 0.85
        }
    };

    // ========================================================================
    // STATE MANAGEMENT (Hybrid)
    // ========================================================================
    const STATE = {
        position: { x: window.innerWidth/2, y: window.innerHeight/2 },
        velocity: { x: 0, y: 0 },
        acceleration: { x: 0, y: 0 },
        lastRawPosition: { x: 0, y: 0 },
        
        lastTimestamp: performance.now(),
        frameCount: 0,
        isLocked: false, // NEW: Pointer lock detection
        
        latency: {
            ping: 0, jitter: 0, decode: 0, total: 75,
            history: [], lastUpdate: 0
        },

        jitterBuffer: [],
        isJittery: false,
        confidence: 1.0,
        velocityMagnitude: 0,
        
        metrics: {
            fps: 0, frameTime: 0, eventsDispatched: 0,
            lastFpsUpdate: 0, framesThisSecond: 0
        },

        overlay: null,
        overlayCtx: null
    };

    // Helper to prevent "non-finite" crashes
    const safeNum = (val) => (Number.isFinite(val) ? val : 0);

    // ========================================================================
    // KALMAN FILTER
    // ========================================================================
    class KalmanFilter {
        constructor() {
            this.Q = 0.01; this.R = 0.1; this.P = 1; this.X = 0; this.K = 0;
        }
        update(measurement) {
            this.P = this.P + this.Q;
            this.K = this.P / (this.P + this.R);
            this.X = this.X + this.K * (measurement - this.X);
            this.P = (1 - this.K) * this.P;
            return this.X;
        }
        reset() { this.P = 1; this.X = 0; }
    }

    const kalmanFilters = {
        x: new KalmanFilter(), y: new KalmanFilter(),
        vx: new KalmanFilter(), vy: new KalmanFilter()
    };

    // ========================================================================
    // AUTO PING DETECTION
    // ========================================================================
    function updateNetworkStats() {
        if (!CONFIG.autoDetection.enabled) return;
        const statsElement = document.querySelector(CONFIG.autoDetection.statsSelector);
        if (!statsElement) return;

        const statsText = statsElement.textContent;
        const pingMatch = statsText.match(/Ping:\s*(\d+)/i);
        const jitterMatch = statsText.match(/Jitter:\s*(\d+)/i);
        const decodeMatch = statsText.match(/Decode:\s*([\d.]+)/i);

        if (pingMatch) {
            STATE.latency.ping = parseInt(pingMatch[1]);
            STATE.latency.jitter = jitterMatch ? parseInt(jitterMatch[1]) : 0;
            STATE.latency.decode = decodeMatch ? parseFloat(decodeMatch[1]) : 0;
            
            const total = STATE.latency.ping + STATE.latency.jitter + STATE.latency.decode + CONFIG.prediction.jitterBuffer;
            STATE.latency.total = Math.max(CONFIG.autoDetection.minLatency, Math.min(CONFIG.autoDetection.maxLatency, total));
        }
    }

    // ========================================================================
    // ADVANCED MOTION TRACKING (Fixed for Pointer Lock)
    // ========================================================================
    function updateMotionState(event) {
        const now = event.timeStamp || performance.now();
        const dt = Math.max(0.001, (now - STATE.lastTimestamp) / 1000);

        STATE.isLocked = !!document.pointerLockElement;

        // Use movementX/Y if locked (in-game), else use clientX/Y (menu)
        const rawDx = STATE.isLocked ? event.movementX : (event.clientX - STATE.lastRawPosition.x);
        const rawDy = STATE.isLocked ? event.movementY : (event.clientY - STATE.lastRawPosition.y);

        // Update velocity
        const rawVx = rawDx / dt;
        const rawVy = rawDy / dt;

        // Jitter detection
        const movementMag = Math.hypot(rawDx, rawDy);
        if (CONFIG.jitter.enabled) {
            STATE.jitterBuffer.push(movementMag);
            if (STATE.jitterBuffer.length > CONFIG.jitter.detectionWindow) STATE.jitterBuffer.shift();
            const avgMovement = STATE.jitterBuffer.reduce((a, b) => a + b, 0) / STATE.jitterBuffer.length;
            STATE.isJittery = avgMovement < CONFIG.jitter.threshold && STATE.jitterBuffer.length === CONFIG.jitter.detectionWindow;
        }

        let filteredVx = (CONFIG.prediction.model === 'kalman') ? kalmanFilters.vx.update(rawVx) : rawVx;
        let filteredVy = (CONFIG.prediction.model === 'kalman') ? kalmanFilters.vy.update(rawVy) : rawVy;

        // Adaptive smoothing
        let alpha = CONFIG.smoothing.velocityAlpha;
        if (CONFIG.smoothing.adaptiveSmoothing) {
            const velMag = Math.hypot(filteredVx, filteredVy);
            const normalizedVel = Math.min(1, velMag / 2000);
            alpha = CONFIG.smoothing.maxAlpha - (normalizedVel * (CONFIG.smoothing.maxAlpha - CONFIG.smoothing.minAlpha));
        }
        if (STATE.isJittery && CONFIG.jitter.adaptiveDamping) alpha *= CONFIG.jitter.dampingFactor;

        // Apply smoothing
        STATE.velocity.x = (filteredVx * alpha) + (STATE.velocity.x * (1 - alpha));
        STATE.velocity.y = (filteredVy * alpha) + (STATE.velocity.y * (1 - alpha));

        // Acceleration
        STATE.acceleration.x = (STATE.velocity.x - (STATE.acceleration.x || 0)) / dt;
        STATE.acceleration.y = (STATE.velocity.y - (STATE.acceleration.y || 0)) / dt;

        // Update raw positions for next frame
        STATE.position.x = event.clientX || STATE.position.x;
        STATE.position.y = event.clientY || STATE.position.y;
        STATE.lastRawPosition.x = event.clientX || STATE.lastRawPosition.x;
        STATE.lastRawPosition.y = event.clientY || STATE.lastRawPosition.y;
        
        STATE.lastTimestamp = now;
        STATE.velocityMagnitude = Math.hypot(STATE.velocity.x, STATE.velocity.y);
        STATE.confidence = Math.max(0.5, 1 - (STATE.velocityMagnitude / 5000));
    }

    // ========================================================================
    // PREDICTION MODEL LOGIC
    // ========================================================================
    function predictMotion() {
        const lookAhead = STATE.latency.total / 1000;
        let pDx, pDy;

        // Core Physics: Displacement = (Vel * t) + (0.5 * Accel * t^2)
        const velX = STATE.velocity.x * lookAhead;
        const velY = STATE.velocity.y * lookAhead;
        const accX = 0.5 * STATE.acceleration.x * lookAhead * lookAhead;
        const accY = 0.5 * STATE.acceleration.y * lookAhead * lookAhead;

        if (CONFIG.prediction.model === 'linear') {
            pDx = velX; pDy = velY;
        } else if (CONFIG.prediction.model === 'quadratic') {
            pDx = velX + accX; pDy = velY + accY;
        } else {
            // Adaptive Hybrid
            const factor = Math.min(1, STATE.velocityMagnitude / 1500);
            pDx = velX + (accX * factor);
            pDy = velY + (accY * factor);
        }

        // Apply adaptive scale for high speed
        if (STATE.velocityMagnitude > 1000) {
            pDx *= CONFIG.prediction.adaptiveScale;
            pDy *= CONFIG.prediction.adaptiveScale;
        }

        // Apply confidence
        const c = Math.max(CONFIG.prediction.confidenceThreshold, STATE.confidence);
        return { x: pDx * c, y: pDy * c };
    }

    // ========================================================================
    // EVENT DISPATCHING (Hybrid Injector)
    // ========================================================================
    function dispatchOptimizedEvent() {
        // IDLE CHECK: Don't flood events if the mouse isn't really moving
        if (STATE.velocityMagnitude < CONFIG.prediction.movementThreshold) return;

        const pred = predictMotion();

        const event = new PointerEvent('pointermove', {
            bubbles: true, cancelable: true, composed: true, view: window,
            // Critical for Pointer Lock (3D camera)
            movementX: safeNum(pred.x),
            movementY: safeNum(pred.y),
            // Critical for Menus (2D cursor)
            clientX: safeNum(STATE.position.x + pred.x),
            clientY: safeNum(STATE.position.y + pred.y),
            pointerType: 'mouse', pointerId: 1, isPrimary: true,
            pressure: CONFIG.input.pointerPressure,
            timeStamp: performance.now()
        });

        const target = document.querySelector('#game-stream video, video, canvas') || window;
        target.dispatchEvent(event);
        STATE.metrics.eventsDispatched++;
    }

    // ========================================================================
    // VISUALS & OVERLAY
    // ========================================================================
    function createOverlay() {
        if (!CONFIG.visual.enabled) return;
        const canvas = document.createElement('canvas');
        canvas.id = 'xcloud-optimizer-v4';
        canvas.width = 350; canvas.height = 180;
        canvas.style.cssText = `position:fixed; ${CONFIG.visual.position.includes('top') ? 'top:10px;' : 'bottom:10px;'} ${CONFIG.visual.position.includes('right') ? 'right:10px;' : 'left:10px;'} pointer-events:none; z-index:999999; background:rgba(0,0,0,${CONFIG.visual.opacity}); border:2px solid #00ff00; border-radius:8px; font-family:monospace;`;
        document.body.appendChild(canvas);
        STATE.overlay = canvas;
        STATE.overlayCtx = canvas.getContext('2d');
    }

    function updateOverlay() {
        if (!STATE.overlayCtx) return;
        const ctx = STATE.overlayCtx;
        ctx.clearRect(0, 0, 350, 180);
        ctx.fillStyle = '#00ff00'; ctx.font = 'bold 13px monospace';
        ctx.fillText(`XCLOUD ULTRA OPTIMIZER v4.2`, 10, 20);
        
        ctx.fillStyle = '#00ffff'; ctx.fillText(`━━ Network ━━`, 10, 45);
        ctx.fillStyle = '#fff';
        ctx.fillText(`Ping: ${STATE.latency.ping}ms`, 10, 60);
        ctx.fillText(`Total Comp: ${STATE.latency.total.toFixed(1)}ms`, 10, 75);

        ctx.fillStyle = '#00ffff'; ctx.fillText(`━━ Motion ━━`, 180, 45);
        ctx.fillStyle = STATE.isLocked ? '#00ff00' : '#ffff00';
        ctx.fillText(`Mode: ${STATE.isLocked ? 'LOCKED' : 'MENU'}`, 180, 60);
        ctx.fillStyle = '#fff';
        ctx.fillText(`Vel: ${STATE.velocityMagnitude.toFixed(0)}px/s`, 180, 75);

        ctx.fillStyle = '#00ffff'; ctx.fillText(`━━ Performance ━━`, 10, 105);
        ctx.fillStyle = '#fff';
        ctx.fillText(`FPS: ${STATE.metrics.fps}`, 10, 120);
        ctx.fillText(`Events: ${STATE.metrics.eventsDispatched}`, 180, 120);

        // Movement Bar
        ctx.fillStyle = '#222'; ctx.fillRect(10, 140, 330, 10);
        ctx.fillStyle = '#00ff00';
        ctx.fillRect(10, 140, Math.min(330, (STATE.velocityMagnitude / 2500) * 330), 10);
    }

    // ========================================================================
    // MAIN LOOP
    // ========================================================================
    function mainLoop(timestamp) {
        STATE.metrics.framesThisSecond++;
        if (timestamp - STATE.metrics.lastFpsUpdate >= 1000) {
            STATE.metrics.fps = STATE.metrics.framesThisSecond;
            STATE.metrics.framesThisSecond = 0;
            STATE.metrics.lastFpsUpdate = timestamp;
        }

        if (CONFIG.input.frameSync) dispatchOptimizedEvent();
        if (CONFIG.visual.enabled) updateOverlay();
        
        requestAnimationFrame(mainLoop);
    }

    // ========================================================================
    // INITIALIZATION
    // ========================================================================
    window.addEventListener('mousemove', updateMotionState, { passive: true, capture: true });
    window.addEventListener('pointermove', updateMotionState, { passive: true, capture: true });
    
    setInterval(updateNetworkStats, CONFIG.autoDetection.updateInterval);
    createOverlay();
    requestAnimationFrame(mainLoop);

    // Public API (v3.0 compatible)
    window.XCloudOptimizer = {
        getStats: () => ({ latency: STATE.latency, locked: STATE.isLocked, velocity: STATE.velocityMagnitude }),
        toggleOverlay: () => { CONFIG.visual.enabled = !CONFIG.visual.enabled; if(!CONFIG.visual.enabled) STATE.overlay.remove(); else createOverlay(); },
        reset: () => { kalmanFilters.vx.reset(); kalmanFilters.vy.reset(); }
    };

    console.log("%c[XCloud Optimizer v4.2] Hybrid Engine Active", "color:#00ff00; font-weight:bold;");
})();
