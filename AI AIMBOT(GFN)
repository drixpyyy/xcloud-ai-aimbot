// ==UserScript==
// @name        GeForce NOW AI Aimbot V7 (Fullscreen Fixed)
// @description Advanced AI Aimbot for GFN. Now with full support for fullscreen mode, adaptive input targeting, and protocol-aware rate limiting.
// @version     7.0.0
// @match       *://play.geforcenow.com/*
// @grant       none
// @run-at      document-end
// @require     https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.18.0/dist/tf.min.js
// @require     https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.0.0/dist/pose-detection.min.js
// ==/UserScript==

(function() {
    'use strict';

    const config = {
        detection: {
            enabled: true,
            modelType: poseDetection.SupportedModels.MoveNet,
            detectorConfig: {
                modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING,
                enableSmoothing: true,
                minPoseScore: 0.20
            },
            keypointConfidence: 0.25,
            maxDetections: 6,
            processingInterval: 10,
            skipFrames: 0,
            ignoreSelfRegion: {
                enabled: true,
                xPercent: 0.40, yPercent: 0.40,
                widthPercent: 0.20, heightPercent: 0.60
            }
        },
        game: {
            videoSelector: '#remote-video',
            containerSelector: 'gfn-browser-streamer', // Fallback for windowed mode
            fullscreenContainerSelector: '#fullscreen-container', // Primary target for fullscreen
            autoShoot: false,
        },
        aim: {
            alwaysOn: { enabled: false },
            activationKey: 'MouseRight',
            toggleMode: false,
            fovRadius: 150,
            aimPoint: "neck",
            targetPriority: "center",
            targetSwitchCooldown: 100,
            triggerThreshold: 0.5,
            aimSpeed: { enabled: true, speedPercent: 45.0 },
            smartSlowdown: {
                enabled: true,
                maxSpeed: 100.0, minSpeed: 15.0,
                slowdownRadius: 80,
                nonlinear: { enabled: true, exponent: 1.2 },
                prediction: { enabled: true },
                velocityBoostFactor: 0.5,
                fpsCompensation: true,
                minFpsThreshold: 30
            },
            prediction: {
                enabled: true,
                latencyCompensation: 40, // Manual latency. Adjust based on your ping. (Your Ping + ~20ms)
                jitterBufferSize: 5,
                maxVelocity: 800,
                smoothingFactor: 0.3,
                predictionScale: 1.0
            }
        },
        visual: {
            showDebugInfo: true,
            esp: { showOnlyWhenAiming: false },
            crosshair: { enabled: true, style: 'dot', color: '#00FF00', size: 2, centerOnGameScreen: true },
            targetLock: { enabled: true, style: 'corners', color: 'red', lineWidth: 2 },
            skeleton: { enabled: true, color: 'rgba(255, 255, 255, 0.8)', lineWidth: 1.5 },
            headDot: { enabled: true, color: 'red', size: 3 },
            tracers: { enabled: true, color: 'rgba(255, 255, 0, 0.4)', lineWidth: 1 },
            fovCircle: { enabled: true, color: 'rgba(255, 255, 255, 0.2)', lineWidth: 1, centerOnGameScreen: true, showOnlyWhenAiming: false },
            performanceMetrics: { enabled: true, position: 'top-left' },
            drawIgnoreRegion: { enabled: false, color: 'rgba(50, 50, 50, 0.4)' }
        }
    };

    const state = {
        gameVideo: null,
        detectionModel: null,
        modelLoaded: false,
        currentTarget: null,
        lastTargetSwitch: 0,
        frameCount: 0,
        lastDetectionTime: 0,
        performance: { fps: 0, framesThisSecond: 0, lastFpsUpdate: 0, detectionTime: 0, avgDetectionTime: 0, detectionTimeHistory: [] },
        ui: { overlayCanvas: null, overlayCtx: null, offscreenCanvas: null, offscreenCtx: null },
        input: { lastMouseX: window.innerWidth / 2, lastMouseY: window.innerHeight / 2, leftButtonDown: false, rightButtonDown: false, activeKeys: new Set(), aimActive: false, lastInputTime: 0 },
        isShooting: false,
        prediction: { targetHistory: {}, backend: 'unknown' }
    };

    const debug = {
        log: (...args) => console.log(`[GFN-Aimbot]`, ...args),
        error: (...args) => console.error(`[GFN-Aimbot]`, ...args)
    };

    function showNotification(message, color = 'rgba(0,0,0,0.7)') {
        const n = document.createElement('div');
        n.style.cssText = `position:fixed;top:20px;left:50%;transform:translateX(-50%);padding:10px 20px;border-radius:5px;color:white;z-index:999999;font-family:sans-serif;font-size:14px;background-color:${color};pointer-events:none;`;
        n.textContent = message;
        document.body.appendChild(n);
        setTimeout(() => n.remove(), 3000);
    }

    // --- Fullscreen & Input Fix ---
    function handleFullscreenChange() {
        setTimeout(() => {
            const fullscreenElement = document.fullscreenElement;
            const overlay = state.ui.overlayCanvas;
            if (!overlay) return;

            if (fullscreenElement && fullscreenElement.id === 'fullscreen-container') {
                debug.log("Entered Fullscreen. Moving overlay into GFN container.");
                fullscreenElement.appendChild(overlay);
                overlay.width = fullscreenElement.clientWidth;
                overlay.height = fullscreenElement.clientHeight;
            } else {
                debug.log("Exited Fullscreen. Moving overlay back to body.");
                document.body.appendChild(overlay);
                overlay.width = window.innerWidth;
                overlay.height = window.innerHeight;
            }
        }, 100); // Small delay to allow DOM to update
    }

    const InputController = {
        init() {
            document.addEventListener('mousemove', e => { state.input.lastMouseX = e.clientX; state.input.lastMouseY = e.clientY; });
            document.addEventListener('mousedown', e => {
                if (e.button === 2) {
                    state.input.rightButtonDown = true;
                    if (config.aim.activationKey === 'MouseRight') {
                        if (config.aim.toggleMode) state.input.aimActive = !state.input.aimActive;
                        else state.input.aimActive = true;
                    }
                }
            });
            document.addEventListener('mouseup', e => {
                if (e.button === 2) {
                    state.input.rightButtonDown = false;
                    if (config.aim.activationKey === 'MouseRight' && !config.aim.toggleMode) {
                        state.input.aimActive = false;
                    }
                }
            });
            if (config.aim.alwaysOn.enabled) state.input.aimActive = true;
        },

        moveMouse(tx, ty) {
            const now = performance.now();
            if (now - state.input.lastInputTime < 8) return; // Rate limit to ~120hz
            state.input.lastInputTime = now;

            // **FULLSCREEN FIX**: Dynamically select the correct input target
            const targetEl = document.fullscreenElement || document.querySelector(config.game.containerSelector) || state.gameVideo;
            if (!targetEl) return;

            const vRect = state.gameVideo.getBoundingClientRect();
            const dx = tx - (vRect.left + vRect.width / 2);
            const dy = ty - (vRect.top + vRect.height / 2);

            const evt = new PointerEvent('pointermove', {
                bubbles: true, cancelable: true, view: window,
                clientX: state.input.lastMouseX + dx, clientY: state.input.lastMouseY + dy,
                screenX: state.input.lastMouseX + dx, screenY: state.input.lastMouseY + dy,
                movementX: dx, movementY: dy,
                pointerType: 'mouse', isPrimary: true
            });
            targetEl.dispatchEvent(evt);
        }
    };

    // --- Core Aimbot & Visuals (no changes needed here from previous version) ---
    async function setupTensorFlow() {
        try {
            const backends = ['webgpu', 'webgl'];
            let selectedBackend = null;
            for (const backend of backends) {
                try {
                    await tf.setBackend(backend);
                    await tf.ready();
                    selectedBackend = backend;
                    if (backend === 'webgl') {
                        tf.env().set('WEBGL_VERSION', 2);
                        tf.env().set('WEBGL_FORCE_F16_TEXTURES', true);
                    }
                    break;
                } catch (e) { console.warn(`Backend ${backend} failed`, e); }
            }
            if (!selectedBackend) throw new Error("No backend available");
            state.prediction.backend = selectedBackend;
            return true;
        } catch (e) { debug.error("TF Setup Failed", e); return false; }
    }

    async function loadDetectionModel() {
        if (!await setupTensorFlow()) return false;
        try {
            state.detectionModel = await poseDetection.createDetector(config.detection.modelType, config.detection.detectorConfig);
            const tC = document.createElement('canvas'); tC.width = 192; tC.height = 192;
            await state.detectionModel.estimatePoses(tC);
            state.modelLoaded = true;
            showNotification(`AI Model Loaded (${state.prediction.backend})`, 'rgba(0,128,0,0.8)');
            return true;
        } catch (e) { debug.error("Model Load Failed", e); showNotification("Model Load Failed", 'rgba(255,0,0,0.8)'); return false; }
    }

    function calculateBoundingBoxFromKeypoints(kps) {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        kps.forEach(k => {
            if (k.score > 0.2) {
                if (k.x < minX) minX = k.x; if (k.x > maxX) maxX = k.x;
                if (k.y < minY) minY = k.y; if (k.y > maxY) maxY = k.y;
            }
        });
        return { x:minX, y:minY, width: maxX - minX, height: maxY - minY };
    }
    
    function calculateAimTarget(pred, vRect) {
        if (!pred.keypoints) return null;
        const getKp = (name) => pred.keypoints.find(k => k.name === name && k.score >= config.detection.keypointConfidence);
        let targetPos = null;
        if (config.aim.aimPoint === 'head') targetPos = getKp('nose');
        else if (config.aim.aimPoint === 'neck') {
            const l = getKp('left_shoulder'), r = getKp('right_shoulder');
            if (l && r) targetPos = { x: (l.x + r.x)/2, y: (l.y + r.y)/2 };
        }
        else if (config.aim.aimPoint === 'torso') {
            const ls = getKp('left_shoulder'), rs = getKp('right_shoulder'), lh = getKp('left_hip'), rh = getKp('right_hip');
            if (ls && rs && lh && rh) targetPos = { x: (ls.x + rs.x + lh.x + rh.x)/4, y: (ls.y + rs.y + lh.y + rh.y)/4 };
        }
        if (!targetPos) {
            const {x, y, width, height} = calculateBoundingBoxFromKeypoints(pred.keypoints);
            targetPos = { x: x + width/2, y: y + height * 0.3 };
        }
        const bbox = calculateBoundingBoxFromKeypoints(pred.keypoints);
        return {
            x: vRect.left + (targetPos.x / state.gameVideo.videoWidth) * vRect.width,
            y: vRect.top + (targetPos.y / state.gameVideo.videoHeight) * vRect.height,
            width: (bbox.width / state.gameVideo.videoWidth) * vRect.width,
            height: (bbox.height / state.gameVideo.videoHeight) * vRect.height,
            bboxRaw: [bbox.x, bbox.y, bbox.width, bbox.height]
        };
    }

    function findBestTarget(predictions) {
        if (!predictions.length || !state.gameVideo) return null;
        const vRect = state.gameVideo.getBoundingClientRect();
        let best = null, minScore = Infinity;
        predictions.forEach((pred, idx) => {
            const tInfo = calculateAimTarget(pred, vRect);
            if (!tInfo) return;
            const dist = Math.hypot(tInfo.x - state.input.lastMouseX, tInfo.y - state.input.lastMouseY);
            if (dist > config.aim.fovRadius) return;
            if (dist < minScore) {
                minScore = dist;
                best = { ...pred, screenPosition: tInfo, distance: dist, id: idx };
            }
        });
        return best;
    }

    function createOverlayCanvas() {
        if (state.ui.overlayCanvas) return;
        const c = document.createElement('canvas');
        c.id = 'gfn-aimbot-overlay';
        c.style.cssText = 'position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:99999;';
        document.body.appendChild(c);
        state.ui.overlayCanvas = c;
        state.ui.overlayCtx = c.getContext('2d');
        const resizeObserver = new ResizeObserver(() => {
            c.width = window.innerWidth;
            c.height = window.innerHeight;
        });
        resizeObserver.observe(document.body);
        // **FULLSCREEN FIX**: Add event listeners
        document.addEventListener('fullscreenchange', handleFullscreenChange);
    }
    
    function drawVisuals(players, target, aimPos) {
        const ctx = state.ui.overlayCtx;
        if (!ctx) return;
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        const vRect = state.gameVideo?.getBoundingClientRect();
        if (!vRect) return;

        if (config.visual.fovCircle.enabled && (!config.visual.fovCircle.showOnlyWhenAiming || state.input.aimActive)) {
            ctx.strokeStyle = config.visual.fovCircle.color; ctx.lineWidth = config.visual.fovCircle.lineWidth;
            ctx.beginPath();
            const cx = vRect.left + vRect.width/2, cy = vRect.top + vRect.height/2;
            ctx.arc(cx, cy, config.aim.fovRadius, 0, Math.PI * 2); ctx.stroke();
        }

        if (config.visual.crosshair.enabled) {
            const cx = vRect.left + vRect.width/2, cy = vRect.top + vRect.height/2;
            ctx.fillStyle = config.visual.crosshair.color; ctx.beginPath();
            ctx.arc(cx, cy, config.visual.crosshair.size, 0, Math.PI * 2); ctx.fill();
        }

        if (players && (!config.visual.esp.showOnlyWhenAiming || state.input.aimActive)) {
            players.forEach(p => {
                if (config.visual.skeleton.enabled && p.keypoints) {
                    ctx.strokeStyle = config.visual.skeleton.color; ctx.lineWidth = config.visual.skeleton.lineWidth;
                    const connections = poseDetection.util.getAdjacentPairs(config.detection.modelType);
                    connections.forEach(([i, j]) => {
                        const kp1 = p.keypoints[i], kp2 = p.keypoints[j];
                        if (kp1.score > 0.3 && kp2.score > 0.3) {
                            const x1 = vRect.left + (kp1.x/state.gameVideo.videoWidth)*vRect.width, y1 = vRect.top + (kp1.y/state.gameVideo.videoHeight)*vRect.height;
                            const x2 = vRect.left + (kp2.x/state.gameVideo.videoWidth)*vRect.width, y2 = vRect.top + (kp2.y/state.gameVideo.videoHeight)*vRect.height;
                            ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
                        }
                    });
                }
                if (config.visual.headDot.enabled) {
                    const nose = p.keypoints.find(k => k.name === 'nose');
                    if (nose && nose.score > 0.3) {
                        const nx = vRect.left + (nose.x/state.gameVideo.videoWidth)*vRect.width, ny = vRect.top + (nose.y/state.gameVideo.videoHeight)*vRect.height;
                        ctx.fillStyle = config.visual.headDot.color;
                        ctx.beginPath(); ctx.arc(nx, ny, config.visual.headDot.size, 0, Math.PI*2); ctx.fill();
                    }
                }
            });
        }
        
        if (target && state.input.aimActive) {
            if (config.visual.tracers.enabled && aimPos) {
                ctx.strokeStyle = config.visual.tracers.color; ctx.lineWidth = config.visual.tracers.lineWidth;
                ctx.beginPath(); ctx.moveTo(vRect.left + vRect.width/2, vRect.top + vRect.height/2); ctx.lineTo(aimPos.x, aimPos.y); ctx.stroke();
            }
            if (config.visual.targetLock.enabled) {
                const tPos = target.screenPosition;
                ctx.strokeStyle = config.visual.targetLock.color; ctx.lineWidth = config.visual.targetLock.lineWidth;
                const [bx,by,bw,bh] = target.bboxRaw;
                const x = vRect.left + (bx/state.gameVideo.videoWidth)*vRect.width;
                const y = vRect.top + (by/state.gameVideo.videoHeight)*vRect.height;
                const w = (bw/state.gameVideo.videoWidth)*vRect.width;
                const h = (bh/state.gameVideo.videoHeight)*vRect.height;
                const s = Math.min(10, w*0.1, h*0.1);
                ctx.beginPath();
                ctx.moveTo(x, y); ctx.lineTo(x + s, y); ctx.moveTo(x, y); ctx.lineTo(x, y + s);
                ctx.moveTo(x + w, y); ctx.lineTo(x + w - s, y); ctx.moveTo(x + w, y); ctx.lineTo(x + w, y + s);
                ctx.moveTo(x, y + h); ctx.lineTo(x + s, y + h); ctx.moveTo(x, y + h); ctx.lineTo(x, y + h - s);
                ctx.moveTo(x + w, y + h); ctx.lineTo(x + w - s, y + h); ctx.moveTo(x + w, y + h); ctx.lineTo(x + w, y + h - s);
                ctx.stroke();
            }
        }

        if (config.visual.performanceMetrics.enabled) {
            ctx.fillStyle = 'lime'; ctx.font = '12px monospace';
            ctx.fillText(`FPS: ${state.performance.fps}`, 10, 20);
            ctx.fillText(`Detect: ${state.performance.avgDetectionTime.toFixed(1)}ms`, 10, 35);
            ctx.fillText(`Backend: ${state.prediction.backend}`, 10, 50);
        }
    }
    
    async function detect() {
        if (!state.gameVideo || state.gameVideo.paused) return [];
        const start = performance.now();
        const poses = await state.detectionModel.estimatePoses(state.gameVideo, { flipHorizontal: false });
        const end = performance.now();
        state.performance.detectionTime = end - start;
        state.performance.detectionTimeHistory.push(state.performance.detectionTime);
        if (state.performance.detectionTimeHistory.length > 30) state.performance.detectionTimeHistory.shift();
        state.performance.avgDetectionTime = state.performance.detectionTimeHistory.reduce((a,b)=>a+b,0) / state.performance.detectionTimeHistory.length;
        return poses.filter(p => p.score >= config.detection.detectorConfig.minPoseScore).map(p => ({ ...p, bbox: calculateBoundingBoxFromKeypoints(p.keypoints) }));
    }

    function calculateFinalAimPosition(tx, ty) {
        if (!config.aim.aimSpeed.enabled) return { x: tx, y: ty };
        const vRect = state.gameVideo.getBoundingClientRect();
        const cx = vRect.left + vRect.width / 2, cy = vRect.top + vRect.height / 2;
        let speed = config.aim.aimSpeed.speedPercent / 100;
        if (config.aim.smartSlowdown.enabled) {
            const dist = Math.hypot(tx - cx, ty - cy);
            if (dist < config.aim.smartSlowdown.slowdownRadius) {
                const factor = Math.pow(dist / config.aim.smartSlowdown.slowdownRadius, config.aim.smartSlowdown.nonlinear.exponent);
                const minS = config.aim.smartSlowdown.minSpeed / 100, maxS = config.aim.smartSlowdown.maxSpeed / 100;
                speed = minS + (maxS - minS) * factor;
            }
        }
        return { x: cx + (tx - cx) * speed, y: cy + (ty - cy) * speed };
    }

    async function loop() {
        requestAnimationFrame(loop);
        const now = performance.now();
        state.performance.framesThisSecond++;
        if (now - state.performance.lastFpsUpdate >= 1000) {
            state.performance.fps = state.performance.framesThisSecond; state.performance.framesThisSecond = 0; state.performance.lastFpsUpdate = now;
        }
        if (state.modelLoaded && state.gameVideo) {
            const players = await detect();
            const target = findBestTarget(players);
            if (target) updateTargetHistory(target.id, target.screenPosition, now);
            let aimPos = null;
            if (target && state.input.aimActive) {
                let tx = target.screenPosition.x, ty = target.screenPosition.y;
                if (config.aim.prediction.enabled) {
                    const predPos = calculatePredictedPosition(target.id);
                    if (predPos) { tx = predPos.x; ty = predPos.y; }
                }
                const final = calculateFinalAimPosition(tx, ty);
                aimPos = final;
                InputController.moveMouse(final.x, final.y);
            }
            drawVisuals(players, target, aimPos);
        }
    }

    async function init() {
        debug.log("Initializing...");
        const video = await new Promise(resolve => {
            const interval = setInterval(() => {
                const el = document.querySelector(config.game.videoSelector);
                if (el && el.readyState >= 1) { clearInterval(interval); resolve(el); }
            }, 500);
        });
        state.gameVideo = video;
        debug.log("Video found:", video);

        createOverlayCanvas();
        InputController.init();
        await loadDetectionModel();
        loop();
    }

    // Start
    if (document.readyState === 'complete') {
        setTimeout(init, 3000);
    } else {
        window.addEventListener('load', () => setTimeout(init, 3000));
    }
})();
