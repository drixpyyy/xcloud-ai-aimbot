// ==UserScript==
// @name         Fortnite xCloud Precision Aimbot (MoveNet) - Pixel Occlusion
// @description  High-performance aimbot using MoveNet with pixel-based self-occlusion.
// @author       Improved Version
// @version      4.2.11
// @match        *://*.xbox.com/play/*
// @grant        none
// @run-at       document-end
// @require      https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core@3.18.0/dist/tf-core.min.js
// @require      https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter@3.18.0/dist/tf-converter.min.js
// @require      https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@3.18.0/dist/tf-backend-webgl.min.js
// @require      https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.0.0/dist/pose-detection.min.js
// ==/UserScript==

(function() {
    'use strict';

    const config = {
        detection: {
            enabled: true,
            modelType: poseDetection.SupportedModels.MoveNet,
            detectorConfig: { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING, enableSmoothing: true, minPoseScore: 0.25, },
            keypointConfidence: 0.20, maxDetections: 5, processingInterval: 30, skipFrames: 1, useWebGL2: true,
            ignoreSelfRegion: { // Your tuned values for pixel occlusion
                enabled: true,
                xPercent: 0.00, yPercent: 0.27, widthPercent: 0.37, heightPercent: 0.74
            }
        },
        game: {
            videoSelector: 'video[aria-label="Game Stream for unknown title"]', containerSelector: '#game-stream',
            recoilCompensation: true, recoilLevel: 3, recoilPatterns: {1:{vertical:0,horizontal:0,recoverySpeed:0.1},2:{vertical:0.15,horizontal:0.03,recoverySpeed:0.15},3:{vertical:0.3,horizontal:0.06,recoverySpeed:0.2},4:{vertical:0.5,horizontal:0.1,recoverySpeed:0.25},5:{vertical:0.7,horizontal:0.15,recoverySpeed:0.35}}, autoShoot: true, triggerOptions: {delayBeforeShoot:10,burstMode:false,burstCount:3,burstInterval:100}, controlOptions: {crouchOnShoot:false,crouchKey:'KeyC',reloadKey:'KeyR',weaponKeys:['Digit1','Digit2','Digit3','Digit4','Digit5']}
        },
        aim: {
            activationKey: 'KeyE',
            fovRadius: 250, instantLock: true, aimPoint: "head", headOffset: 0.15, bodyOffset: 0.4, targetPriority: "center", targetSwitchCooldown: 250, triggerThreshold: 0.7, smoothing: {enabled:false,amount:0.0,extrapolation:false}, snapOptions: {strength:1,threshold:0.9,diminishingRange:false}
        },
        visual: {
            showDebugInfo: true, crosshair: {enabled:true,style:'dot',color:'lime',size:3,centerOnGameScreen:true},
            boundingBoxes: {enabled:true,color:'lime',lineWidth:1,fillColor:'rgba(0,255,0,0.1)',showInfo:true,fromKeypoints:true},
            keypoints: {enabled:true,color:'cyan',radius:3}, targetLock: {enabled:true,color:'yellow',style:'corners'},
            fovCircle: {enabled:true,color:'rgba(255,255,255,0.3)',lineWidth:1,centerOnGameScreen:true},
            performanceMetrics: {enabled:true,position:'top-left'},
            drawIgnoreRegion: { // Visual guide for the occlusion area
                enabled: true,
                color: 'rgba(30, 30, 30, 0.5)', // Semi-transparent dark grey for VISUAL guide
                lineWidth: 1
            }
        }
    };
    config.version = '4.2.11';

    const tfState = { backend: 'webgl', flags: { WEBGL_FORCE_F16_TEXTURES: false, WEBGL_VERSION: config.detection.useWebGL2 ? 2 : 1, } };
    const state = {
        gameVideo: null, detectionModel: null, modelLoaded: false, detectionActive: false, currentTarget: null,
        lastTargetSwitch: 0, lastDetectionTime: 0, frameCount: 0, currentWeapon: 0, isShooting: false,
        recoilState: { active: false, offsetX: 0, offsetY: 0, shotsFired: 0, lastShotTime: 0 },
        performance: { fps: 0, lastFpsUpdate: 0, framesThisSecond: 0, detectionTime: 0, avgDetectionTime: 0, detectionTimeHistory: [] },
        ui: { overlayCanvas: null, overlayCtx: null, offscreenCanvas: null, offscreenCtx: null, guiElements: {} }, // Added offscreenCanvas/Ctx
        input: { lastMouseX: window.innerWidth / 2, lastMouseY: window.innerHeight / 2, leftButtonDown: false, rightButtonDown: false, activeKeys: new Set() }
    };
    const debug = { log: (...args) => console.log(`[AimbotV${config.version}-MoveNet]`, ...args), warn: (...args) => console.warn(`[AimbotV${config.version}-MoveNet]`, ...args), error: (...args) => console.error(`[AimbotV${config.version}-MoveNet]`, ...args), };

    function showNotification(message, type = 'info', duration = 3000) { const n=document.createElement('div');n.style.cssText=`position:fixed;top:20px;left:50%;transform:translateX(-50%);padding:10px 20px;border-radius:5px;color:white;z-index:1000000;font-family:sans-serif;font-size:16px;box-shadow:0 2px 10px rgba(0,0,0,0.2);background-color:${type==='error'?'rgba(255,0,0,0.8)':type==='warning'?'rgba(255,165,0,0.8)':'rgba(0,0,0,0.7)'};`;n.textContent=message;document.body.appendChild(n);setTimeout(()=>n.remove(),duration); }
    async function setupTensorFlow() { try{debug.log("Configuring TF.js...");await tf.setBackend(tfState.backend);await tf.ready();for(const f in tfState.flags)tf.env().set(f,tfState.flags[f]);debug.log(`TF.js backend: ${tf.getBackend()}`);if(tf.getBackend()==='webgl')debug.log(`WebGL Version: ${tf.env().get('WEBGL_VERSION')}`);const sT=performance.now();const tT=tf.zeros([100,100,3]);await tT.data();tT.dispose();debug.log(`TF basic op test: ${(performance.now()-sT).toFixed(2)}ms`);return!0}catch(e){debug.error("TF setup failed:",e);return!1} }
    async function loadDetectionModel() { debug.log("Loading MoveNet model...");try{if(!await setupTensorFlow())throw Error("TF setup failed");if("undefined"==typeof poseDetection)throw Error("Pose Detection API not loaded.");state.detectionModel=await poseDetection.createDetector(config.detection.modelType,config.detection.detectorConfig);const tC=document.createElement('canvas');tC.width=192;tC.height=192;await state.detectionModel.estimatePoses(tC);state.modelLoaded=!0;debug.log("MoveNet model loaded!");showNotification("AI Model (MoveNet) Loaded!","info");return!0}catch(e){debug.error("Failed to load MoveNet model:",e);showNotification("Error loading AI model (MoveNet)! Check console.","error");return!1} }
    function calculateBoundingBoxFromKeypoints(kps) { if(!kps||0===kps.length)return null;let mX=Infinity,mY=Infinity,mAX=-Infinity,mAY=-Infinity,vK=0;kps.forEach(k=>{if(k.score&&k.score>=config.detection.keypointConfidence){mX=Math.min(mX,k.x);mY=Math.min(mY,k.y);mAX=Math.max(mAX,k.x);mAY=Math.max(mAY,k.y);vK++}});if(vK<5)return null;const w=mAX-mX,h=mAY-mY,pX=0.1*w,pY=0.1*h;return{x:Math.max(0,mX-pX),y:Math.max(0,mY-pY),width:mAX-mX+2*pX,height:mAY-mY+2*pY,validKeypoints:vK}}

    // MODIFIED: detectPlayers to use pixel occlusion
    async function detectPlayers() {
        if (!state.gameVideo || !state.modelLoaded || !state.detectionModel || state.gameVideo.paused || state.gameVideo.ended || state.gameVideo.videoWidth === 0 || state.gameVideo.videoHeight === 0) {
            return [];
        }
        if (state.frameCount % (config.detection.skipFrames + 1) !== 0) {
            state.frameCount++; return [];
        }
        state.frameCount++;
        const now = performance.now();
        if (now - state.lastDetectionTime < config.detection.processingInterval) {
            return [];
        }

        let videoSource = state.gameVideo; // Default source is the live video

        // If self-region occlusion is enabled, draw on an offscreen canvas
        if (config.detection.ignoreSelfRegion.enabled) {
            if (!state.ui.offscreenCanvas) { // Create offscreen canvas if it doesn't exist
                state.ui.offscreenCanvas = document.createElement('canvas');
                state.ui.offscreenCtx = state.ui.offscreenCanvas.getContext('2d');
            }
            // Match offscreen canvas dimensions to video dimensions
            if (state.ui.offscreenCanvas.width !== state.gameVideo.videoWidth || state.ui.offscreenCanvas.height !== state.gameVideo.videoHeight) {
                state.ui.offscreenCanvas.width = state.gameVideo.videoWidth;
                state.ui.offscreenCanvas.height = state.gameVideo.videoHeight;
            }

            const ctx = state.ui.offscreenCtx;
            // 1. Draw current video frame to offscreen canvas
            ctx.drawImage(state.gameVideo, 0, 0, state.gameVideo.videoWidth, state.gameVideo.videoHeight);

            // 2. Draw solid black occlusion box onto the offscreen canvas
            const region = config.detection.ignoreSelfRegion;
            const rectX = state.gameVideo.videoWidth * region.xPercent;
            const rectY = state.gameVideo.videoHeight * region.yPercent;
            const rectW = state.gameVideo.videoWidth * region.widthPercent;
            const rectH = state.gameVideo.videoHeight * region.heightPercent;

            ctx.fillStyle = 'rgba(0, 0, 0, 1)'; // Solid black
            ctx.fillRect(rectX, rectY, rectW, rectH);

            videoSource = state.ui.offscreenCanvas; // AI will process this modified canvas
        }

        try {
            const detectionStart = performance.now();
            const poses = await state.detectionModel.estimatePoses(videoSource, { flipHorizontal: false });
            const detectionEnd = performance.now();
            state.performance.detectionTime = detectionEnd - detectionStart;
            state.performance.detectionTimeHistory.push(state.performance.detectionTime);
            if (state.performance.detectionTimeHistory.length > 30) state.performance.detectionTimeHistory.shift();
            state.performance.avgDetectionTime = state.performance.detectionTimeHistory.reduce((a, b) => a + b, 0) / state.performance.detectionTimeHistory.length;
            state.lastDetectionTime = now;

            const results = [];
            if (poses && poses.length > 0) {
                for (const pose of poses) {
                    if (pose.score && pose.score >= config.detection.detectorConfig.minPoseScore) {
                        const bbox = calculateBoundingBoxFromKeypoints(pose.keypoints);
                        if (bbox && bbox.width > 0 && bbox.height > 0) {
                            results.push({ class: 'person', score: pose.score, bbox: [bbox.x, bbox.y, bbox.width, bbox.height], keypoints: pose.keypoints });
                        }
                    }
                }
            }
            return results.slice(0, config.detection.maxDetections);
        } catch (err) {
            debug.error("Error during pose estimation:", err);
            return [];
        }
    }

    function calculateAimTarget(pred,vRect){const[vBx,vBy,vBw,vBh]=pred.bbox,sBx=vRect.left+vBx/state.gameVideo.videoWidth*vRect.width,sBy=vRect.top+vBy/state.gameVideo.videoHeight*vRect.height,sBw=vBw/state.gameVideo.videoWidth*vRect.width,sBh=vBh/state.gameVideo.videoHeight*vRect.height;let tX,tY;const kps=pred.keypoints,gK=n=>kps.find(k=>k.name===n&&k.score>=config.detection.keypointConfidence);switch(config.aim.aimPoint){case"head":const n=gK('nose'),lE=gK('left_eye'),rE=gK('right_eye');n?(tX=vRect.left+n.x/state.gameVideo.videoWidth*vRect.width,tY=vRect.top+n.y/state.gameVideo.videoHeight*vRect.height):lE&&rE?(tX=vRect.left+((lE.x+rE.x)/2)/state.gameVideo.videoWidth*vRect.width,tY=vRect.top+((lE.y+rE.y)/2)/state.gameVideo.videoHeight*vRect.height):(tX=sBx+sBw/2,tY=sBy+sBh*config.aim.headOffset);break;case"neck":const lS_n=gK('left_shoulder'),rS_n=gK('right_shoulder');lS_n&&rS_n?(tX=vRect.left+((lS_n.x+rS_n.x)/2)/state.gameVideo.videoWidth*vRect.width,tY=vRect.top+((lS_n.y+rS_n.y)/2-vBh*0.05)/state.gameVideo.videoHeight*vRect.height):(tX=sBx+sBw/2,tY=sBy+sBh*(config.aim.headOffset+0.1));break;case"torso_center":const lS_t=gK('left_shoulder'),rS_t=gK('right_shoulder'),lH_t=gK('left_hip'),rH_t=gK('right_hip');lS_t&&rS_t&&lH_t&&rH_t?(tX=vRect.left+(((lS_t.x+rS_t.x)/2+(lH_t.x+rH_t.x)/2)/2)/state.gameVideo.videoWidth*vRect.width,tY=vRect.top+(((lS_t.y+rS_t.y)/2+(lH_t.y+rH_t.y)/2)/2)/state.gameVideo.videoHeight*vRect.height):(tX=sBx+sBw/2,tY=sBy+sBh*config.aim.bodyOffset);break;case"center":default:tX=sBx+sBw/2;tY=sBy+sBh/2;break}return{x:tX,y:tY,width:sBw,height:sBh,bboxRaw:pred.bbox,keypoints:pred.keypoints}}
    // The findBestTarget function no longer needs the ignoreRect logic within it, as occlusion happens before detection.
    function findBestTarget(predictions) { if (!predictions || predictions.length === 0 || !state.gameVideo) return null; const videoRect = state.gameVideo.getBoundingClientRect(); if (!videoRect || videoRect.width === 0) return null; const gameScreenCenterX = videoRect.left + videoRect.width / 2; const gameScreenCenterY = videoRect.top + videoRect.height / 2; let bestTarget = null; let bestScore = Infinity; predictions.forEach(prediction => { const targetInfo = calculateAimTarget(prediction, videoRect); let referenceX, referenceY; if (config.aim.targetPriority === "center") { referenceX = gameScreenCenterX; referenceY = gameScreenCenterY; } else { referenceX = state.input.lastMouseX; referenceY = state.input.lastMouseY; } const dx = targetInfo.x - referenceX; const dy = targetInfo.y - referenceY; const distanceToPriorityPoint = Math.sqrt(dx * dx + dy * dy); let fovCenterX = config.visual.fovCircle.centerOnGameScreen && videoRect ? gameScreenCenterX : state.input.lastMouseX; let fovCenterY = config.visual.fovCircle.centerOnGameScreen && videoRect ? gameScreenCenterY : state.input.lastMouseY; const dx_fov = targetInfo.x - fovCenterX; const dy_fov = targetInfo.y - fovCenterY; if (Math.sqrt(dx_fov*dx_fov + dy_fov*dy_fov) > config.aim.fovRadius) return; let score; switch (config.aim.targetPriority) { case "size": score = targetInfo.width * targetInfo.height > 0 ? 1 / (targetInfo.width * targetInfo.height) : Infinity; break; case "distance": case "center": case "crosshair": default: score = distanceToPriorityPoint; break; } if (score < bestScore) { bestScore = score; bestTarget = { prediction, screenPosition: targetInfo, distance: distanceToPriorityPoint, score: prediction.score }; } }); return bestTarget; }
    function applyRecoilCompensation(tX,tY){if(!config.game.recoilCompensation||!state.isShooting){if(0!==state.recoilState.offsetX||0!==state.recoilState.offsetY){const rS=config.game.recoilPatterns[config.game.recoilLevel]||{recoverySpeed:0.1};state.recoilState.offsetX*=1-rS.recoverySpeed;state.recoilState.offsetY*=1-rS.recoverySpeed;Math.abs(state.recoilState.offsetX)<0.01&&(state.recoilState.offsetX=0);Math.abs(state.recoilState.offsetY)<0.01&&(state.recoilState.offsetY=0)}return{x:tX,y:tY}}const rS=config.game.recoilPatterns[config.game.recoilLevel]||config.game.recoilPatterns[3],now=performance.now();if(state.isShooting){if(0===state.recoilState.shotsFired||now-state.recoilState.lastShotTime>300){const kM=1.5;state.recoilState.offsetY=rS.vertical*kM;state.recoilState.offsetX=2*(Math.random()-0.5)*rS.horizontal*kM}else{state.recoilState.offsetY+=rS.vertical*(0.3+0.7*Math.random());state.recoilState.offsetX+=(Math.random()-0.5)*rS.horizontal*2;state.recoilState.offsetY=Math.min(state.recoilState.offsetY,5*rS.vertical);state.recoilState.offsetX=Math.min(Math.abs(state.recoilState.offsetX),3*rS.horizontal)*(state.recoilState.offsetX<0?-1:1)}state.recoilState.shotsFired++;state.recoilState.lastShotTime=now}let fX=tX-state.recoilState.offsetX,fY=tY-state.recoilState.offsetY;state.recoilState.offsetX*=1-rS.recoverySpeed;state.recoilState.offsetY*=1-rS.recoverySpeed;return{x:fX,y:fY}}
    const InputController={init(){state.input.lastMouseX=window.innerWidth/2;state.input.lastMouseY=window.innerHeight/2;document.addEventListener('mousemove',e=>{state.input.lastMouseX=e.clientX;state.input.lastMouseY=e.clientY});this.setupKeyMonitoring();debug.log("Input controller initialized");return!0},setupKeyMonitoring(){document.addEventListener('keydown',e=>{state.input.activeKeys.add(e.code);if(e.code===config.game.controlOptions.crouchKey)debug.log(`Crouch key pressed (${e.code})`);if(e.code===config.aim.activationKey)debug.log(`Aim activation key (${e.code}) pressed.`);config.game.controlOptions.weaponKeys.forEach((k,i)=>{e.code===k&&(state.currentWeapon=i,debug.log(`Switched to weapon slot ${i+1}`))})});document.addEventListener('keyup',e=>{state.input.activeKeys.delete(e.code);if(e.code===config.aim.activationKey)debug.log(`Aim activation key (${e.code}) released.`);});document.addEventListener('mousedown',e=>{0===e.button&&(state.input.leftButtonDown=!0);2===e.button&&(state.input.rightButtonDown=!0)});document.addEventListener('mouseup',e=>{0===e.button&&(state.input.leftButtonDown=!1);2===e.button&&(state.input.rightButtonDown=!1)})},moveMouseTo(tSX,tSY){if(!state.gameVideo)return;const vR=state.gameVideo.getBoundingClientRect();if(!vR||0===vR.width)return;const gVCX=vR.left+vR.width/2,gVCY=vR.top+vR.height/2,mX=tSX-gVCX,mY=tSY-gVCY;if(Math.abs(mX)<0.1&&Math.abs(mY)<0.1)return;const sC=document.querySelector(config.game.containerSelector)||state.gameVideo||document.documentElement,evt=new PointerEvent('pointermove',{bubbles:!0,cancelable:!0,view:window,clientX:Math.round(state.input.lastMouseX+mX),clientY:Math.round(state.input.lastMouseY+mY),screenX:Math.round(state.input.lastMouseX+mX),screenY:Math.round(state.input.lastMouseY+mY),movementX:Math.round(mX),movementY:Math.round(mY),buttons:state.input.leftButtonDown?1:state.input.rightButtonDown?2:0,pointerType:'mouse',isPrimary:!0});sC.dispatchEvent(evt)},startShooting(){if(state.isShooting)return;const sC=document.querySelector(config.game.containerSelector)||state.gameVideo||document.documentElement,evt=new PointerEvent('pointerdown',{bubbles:!0,cancelable:!0,view:window,clientX:Math.round(state.input.lastMouseX),clientY:Math.round(state.input.lastMouseY),button:0,buttons:1,pointerType:'mouse',isPrimary:!0});sC.dispatchEvent(evt);state.isShooting=!0;state.recoilState.shotsFired=0;debug.log("Shooting started (simulated)");config.game.controlOptions.crouchOnShoot&&!state.input.activeKeys.has(config.game.controlOptions.crouchKey)&&this.pressKey(config.game.controlOptions.crouchKey,0)},stopShooting(){if(!state.isShooting)return;const sC=document.querySelector(config.game.containerSelector)||state.gameVideo||document.documentElement,evt=new PointerEvent('pointerup',{bubbles:!0,cancelable:!0,view:window,clientX:Math.round(state.input.lastMouseX),clientY:Math.round(state.input.lastMouseY),button:0,buttons:0,pointerType:'mouse',isPrimary:!0});sC.dispatchEvent(evt);state.isShooting=!1;debug.log("Shooting stopped (simulated)");config.game.controlOptions.crouchOnShoot&&state.input.activeKeys.has(config.game.controlOptions.crouchKey)&&this.releaseKey(config.game.controlOptions.crouchKey)},pressKey(kC,dur=50){const k=kC.replace(/^(Key|Digit)/,''),eT=document.activeElement||document.body,dE=new KeyboardEvent('keydown',{code:kC,key:k,keyCode:kC.startsWith('Digit')?parseInt(k):1===k.length?k.charCodeAt(0):0,bubbles:!0,cancelable:!0,view:window});eT.dispatchEvent(dE);state.input.activeKeys.add(kC);dur>0&&setTimeout(()=>this.releaseKey(kC),dur)},releaseKey(kC){const k=kC.replace(/^(Key|Digit)/,''),eT=document.activeElement||document.body,uE=new KeyboardEvent('keyup',{code:kC,key:k,keyCode:kC.startsWith('Digit')?parseInt(k):1===k.length?k.charCodeAt(0):0,bubbles:!0,cancelable:!0,view:window});eT.dispatchEvent(uE);state.input.activeKeys.delete(kC)},reload(){this.pressKey(config.game.controlOptions.reloadKey,50);debug.log("Reload key pressed")},switchWeapon(sI){sI>=0&&sI<config.game.controlOptions.weaponKeys.length&&(this.pressKey(config.game.controlOptions.weaponKeys[sI],50),state.currentWeapon=sI,debug.log(`Switched to weapon slot ${sI+1}`))}};
    function startAimbotLoop(){debug.log("Starting main aimbot loop");let mLActive=!0;async function mL(ts){if(!mLActive)return;requestAnimationFrame(mL);state.performance.framesThisSecond++;ts-state.performance.lastFpsUpdate>=1E3&&(state.performance.fps=state.performance.framesThisSecond,state.performance.framesThisSecond=0,state.performance.lastFpsUpdate=ts);if(!state.gameVideo||state.gameVideo.paused||state.gameVideo.ended||0===state.gameVideo.videoWidth){state.isShooting&&InputController.stopShooting();state.ui.overlayCtx&&state.ui.overlayCtx.clearRect(0,0,state.ui.overlayCanvas.width,state.ui.overlayCanvas.height);state.currentTarget=null;return}await processAiming(ts)}requestAnimationFrame(mL)}
    async function processAiming(timestamp) { if (!config.detection.enabled || !state.modelLoaded) { drawVisuals([], null); return; } const players = await detectPlayers(); const target = findBestTarget(players); drawVisuals(players, target); if (target && state.input.activeKeys.has(config.aim.activationKey)) { const now = timestamp; if (!state.currentTarget || now - state.lastTargetSwitch > config.aim.targetSwitchCooldown) { if (!state.currentTarget || state.currentTarget.prediction !== target.prediction) { debug.log(`New target acquired: Score ${target.score.toFixed(2)}, dist: ${target.distance.toFixed(0)}px`); state.lastTargetSwitch = now; } state.currentTarget = target; } if (state.currentTarget) { let { x: targetX, y: targetY } = state.currentTarget.screenPosition; const compensatedPos = applyRecoilCompensation(targetX, targetY); targetX = compensatedPos.x; targetY = compensatedPos.y; if (config.aim.instantLock) InputController.moveMouseTo(targetX, targetY); if (config.game.autoShoot && state.currentTarget.distance < config.aim.fovRadius * config.aim.triggerThreshold) { if (!state.isShooting) { setTimeout(() => { if (state.currentTarget && state.input.activeKeys.has(config.aim.activationKey)) { InputController.startShooting(); } }, config.game.triggerOptions.delayBeforeShoot); } } else if (state.isShooting && !config.game.triggerOptions.burstMode) { InputController.stopShooting(); } } } else { state.currentTarget = null; if (state.isShooting && !config.game.triggerOptions.burstMode) { InputController.stopShooting(); } } }
    function createOverlayCanvas(){if(state.ui.overlayCanvas)return;const c=document.createElement('canvas');c.id='xcloud-aimbot-overlay';c.width=window.innerWidth;c.height=window.innerHeight;c.style.cssText='position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:99999;';state.ui.overlayCanvas=c;state.ui.overlayCtx=c.getContext('2d');document.body.appendChild(c);window.addEventListener('resize',()=>{c.width=window.innerWidth;c.height=window.innerHeight});debug.log("Overlay canvas created")}
    function drawCrosshair(vR){if(!state.ui.overlayCtx||!config.visual.crosshair.enabled)return;const ctx=state.ui.overlayCtx;let cX,cY;config.visual.crosshair.centerOnGameScreen&&vR&&vR.width>0?(cX=vR.left+vR.width/2,cY=vR.top+vR.height/2):(cX=state.input.lastMouseX,cY=state.input.lastMouseY);const s=config.visual.crosshair.size;ctx.strokeStyle=config.visual.crosshair.color;ctx.fillStyle=config.visual.crosshair.color;ctx.lineWidth=1;switch(config.visual.crosshair.style){case'cross':ctx.beginPath();ctx.moveTo(cX-2*s,cY);ctx.lineTo(cX+2*s,cY);ctx.moveTo(cX,cY-2*s);ctx.lineTo(cX,cY+2*s);ctx.stroke();break;case'dot':ctx.beginPath();ctx.arc(cX,cY,s,0,2*Math.PI);ctx.fill();break;case'circle':ctx.beginPath();ctx.arc(cX,cY,2*s,0,2*Math.PI);ctx.stroke();break}}
    function drawKeypoints(ps,vR){if(!config.visual.keypoints.enabled||!state.ui.overlayCtx||!ps||0===ps.length||!vR)return;const ctx=state.ui.overlayCtx;ps.forEach(p=>{p.keypoints&&p.keypoints.forEach(kP=>{if(kP.score&&kP.score>=config.detection.keypointConfidence){const sX=vR.left+kP.x/state.gameVideo.videoWidth*vR.width,sY=vR.top+kP.y/state.gameVideo.videoHeight*vR.height;ctx.beginPath();ctx.arc(sX,sY,config.visual.keypoints.radius,0,2*Math.PI);ctx.fillStyle=config.visual.keypoints.color;ctx.fill()}})})};
    function drawBoundingBoxes(ps,vR){if(!config.visual.boundingBoxes.enabled||!state.ui.overlayCtx||!ps||0===ps.length||!vR)return;const ctx=state.ui.overlayCtx;ps.forEach(p=>{const[vBx,vBy,vBw,vBh]=p.bbox,sX=vR.left+vBx/state.gameVideo.videoWidth*vR.width,sY=vR.top+vBy/state.gameVideo.videoHeight*vR.height,sW=vBw/state.gameVideo.videoWidth*vR.width,sH=vBh/state.gameVideo.videoHeight*vR.height;ctx.strokeStyle=config.visual.boundingBoxes.color;ctx.lineWidth=config.visual.boundingBoxes.lineWidth;ctx.fillStyle=config.visual.boundingBoxes.fillColor;ctx.fillRect(sX,sY,sW,sH);ctx.strokeRect(sX,sY,sW,sH);if(config.visual.boundingBoxes.showInfo){ctx.fillStyle=config.visual.boundingBoxes.color;ctx.font='12px Arial';const sT=`${(100*p.score).toFixed(0)}%`;ctx.fillText(sT,sX+5,sY+15);if(p.keypoints&&config.visual.boundingBoxes.fromKeypoints){const kC=p.keypoints.filter(kP=>kP.score>=config.detection.keypointConfidence).length;ctx.fillText(`KPs: ${kC}`,sX+5,sY+30)}}})};
    function drawTargetLockIndicator(t,vR){if(!config.visual.targetLock.enabled||!state.ui.overlayCtx||!t||!vR)return;const ctx=state.ui.overlayCtx,[vBx,vBy,vBw,vBh]=t.prediction.bbox,bSX=vR.left+vBx/state.gameVideo.videoWidth*vR.width,bSY=vR.top+vBy/state.gameVideo.videoHeight*vR.height,bSW=vBw/state.gameVideo.videoWidth*vR.width,bSH=vBh/state.gameVideo.videoHeight*vR.height;ctx.strokeStyle=config.visual.targetLock.color;ctx.lineWidth=2;const cS=0.2*Math.min(bSW,bSH);switch(config.visual.targetLock.style){case'full':ctx.strokeRect(bSX,bSY,bSW,bSH);break;case'corners':ctx.beginPath();ctx.moveTo(bSX+cS,bSY);ctx.lineTo(bSX,bSY);ctx.lineTo(bSX,bSY+cS);ctx.moveTo(bSX+bSW-cS,bSY);ctx.lineTo(bSX+bSW,bSY);ctx.lineTo(bSX+bSW,bSY+cS);ctx.moveTo(bSX+cS,bSY+bSH);ctx.lineTo(bSX,bSY+bSH);ctx.lineTo(bSX,bSY+bSH-cS);ctx.moveTo(bSX+bSW-cS,bSY+bSH);ctx.lineTo(bSX+bSW,bSY+bSH);ctx.lineTo(bSX+bSW,bSY+bSH-cS);ctx.stroke();break;case'crosshair':const cSz=10;ctx.beginPath();ctx.moveTo(t.screenPosition.x-cSz,t.screenPosition.y);ctx.lineTo(t.screenPosition.x+cSz,t.screenPosition.y);ctx.moveTo(t.screenPosition.x,t.screenPosition.y-cSz);ctx.lineTo(t.screenPosition.x,t.screenPosition.y+cSz);ctx.stroke();break}};
    function drawFOVCircle(vR){if(!config.visual.fovCircle.enabled||!state.ui.overlayCtx)return;const ctx=state.ui.overlayCtx;let cX,cY;config.visual.fovCircle.centerOnGameScreen&&vR&&vR.width>0?(cX=vR.left+vR.width/2,cY=vR.top+vR.height/2):(cX=state.input.lastMouseX,cY=state.input.lastMouseY);ctx.strokeStyle=config.visual.fovCircle.color;ctx.lineWidth=config.visual.fovCircle.lineWidth;ctx.beginPath();ctx.arc(cX,cY,config.aim.fovRadius,0,2*Math.PI);ctx.stroke()};
    function drawPerformanceMetrics(){if(!config.visual.performanceMetrics.enabled||!state.ui.overlayCtx)return;const ctx=state.ui.overlayCtx,ms=[`FPS: ${state.performance.fps}`,`Detect: ${state.performance.detectionTime.toFixed(1)}ms (Avg: ${state.performance.avgDetectionTime.toFixed(1)}ms)`];ctx.font='14px Arial';ctx.fillStyle='rgba(0,255,0,0.8)';const lH=16;let sX=10,sY=20;switch(config.visual.performanceMetrics.position){case'top-right':sX=state.ui.overlayCanvas.width-200;break;case'bottom-left':sY=state.ui.overlayCanvas.height-ms.length*lH-10;break;case'bottom-right':sX=state.ui.overlayCanvas.width-200;sY=state.ui.overlayCanvas.height-ms.length*lH-10;break}ms.forEach((m,i)=>ctx.fillText(m,sX,sY+i*lH))};
    function drawDebugInfo(){ if(!config.visual.showDebugInfo||!state.ui.overlayCtx)return; const ctx=state.ui.overlayCtx; const aimingActive = state.input.activeKeys.has(config.aim.activationKey); const dL=[ `Target: ${state.currentTarget?`Yes (Score: ${state.currentTarget.score.toFixed(2)})`:"No"}`, `Shooting: ${state.isShooting?"Yes":"No"} | Aiming (${config.aim.activationKey.replace('Key','')})${aimingActive?" (Active)":" (Inactive)"}`, `Recoil X: ${state.recoilState.offsetX.toFixed(2)} Y: ${state.recoilState.offsetY.toFixed(2)}`, `OS Mouse: X:${state.input.lastMouseX.toFixed(0)} Y:${state.input.lastMouseY.toFixed(0)}` ]; ctx.font='12px Arial';ctx.fillStyle='rgba(255,255,0,0.8)';const lH=15;let sY=80; if(config.visual.performanceMetrics.enabled&&"top-left"===config.visual.performanceMetrics.position)sY=20+(state.performance.fps>0?2:1)*16+20; let sX=10; if(config.visual.performanceMetrics.enabled&&"bottom-left"===config.visual.performanceMetrics.position&&config.visual.showDebugInfo)sY=state.ui.overlayCanvas.height-(state.performance.fps>0?2:1)*16-10-dL.length*lH-10; dL.forEach((l,i)=>ctx.fillText(l,sX,sY+i*lH)); }
    function drawIgnoreSelfRegionVisualization(videoRect) { if (!config.detection.ignoreSelfRegion.enabled || !config.visual.drawIgnoreRegion.enabled || !state.ui.overlayCtx || !videoRect || videoRect.width === 0) return; const ctx = state.ui.overlayCtx; const region = config.detection.ignoreSelfRegion; const visConfig = config.visual.drawIgnoreRegion; const rectX = videoRect.left + videoRect.width * region.xPercent; const rectY = videoRect.top + videoRect.height * region.yPercent; const rectW = videoRect.width * region.widthPercent; const rectH = videoRect.height * region.heightPercent; ctx.fillStyle = visConfig.color; ctx.fillRect(rectX, rectY, rectW, rectH); if (visConfig.lineWidth > 0) { ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; ctx.lineWidth = visConfig.lineWidth; ctx.strokeRect(rectX, rectY, rectW, rectH); } }
    function drawVisuals(ps,cT){ if(!state.ui.overlayCtx)return; const ctx=state.ui.overlayCtx,cvs=state.ui.overlayCanvas; ctx.clearRect(0,0,cvs.width,cvs.height); const vR=state.gameVideo?state.gameVideo.getBoundingClientRect():null; config.visual.crosshair.enabled&&drawCrosshair(vR); config.visual.fovCircle.enabled&&drawFOVCircle(vR); if (config.detection.ignoreSelfRegion.enabled && config.visual.drawIgnoreRegion.enabled && vR) { drawIgnoreSelfRegionVisualization(vR); } if(vR&&vR.width>0){ config.visual.boundingBoxes.enabled&&drawBoundingBoxes(ps,vR); config.visual.keypoints.enabled&&drawKeypoints(ps,vR); config.visual.targetLock.enabled&&cT&&drawTargetLockIndicator(cT,vR) } config.visual.performanceMetrics.enabled&&drawPerformanceMetrics(); config.visual.showDebugInfo&&drawDebugInfo() }
    async function initializeAimbot(){ debug.log(`Initializing Aimbot V${config.version} (MoveNet)...`); state.gameVideo=document.querySelector(config.game.videoSelector); if(!state.gameVideo){debug.error("Game video element not found. Retrying...");showNotification("Error: Game video not found! Aimbot cannot start.","error",5E3);setTimeout(initializeAimbot,3E3);return} debug.log("Game video element found:",state.gameVideo); if(state.gameVideo.readyState<state.gameVideo.HAVE_METADATA){ debug.log("Waiting for video metadata..."); try{await new Promise((rs,rj)=>{state.gameVideo.onloadedmetadata=rs;state.gameVideo.onerror=rj});debug.log(`Video metadata loaded: ${state.gameVideo.videoWidth}x${state.gameVideo.videoHeight}`)} catch(vE){debug.error("Error loading video metadata:",vE);showNotification("Error loading video. Aimbot might not work correctly.","error");setTimeout(initializeAimbot,5E3);return} } else { debug.log(`Video dimensions readily available: ${state.gameVideo.videoWidth}x${state.gameVideo.videoHeight}`); } createOverlayCanvas(); if(!InputController.init()){debug.error("Input controller failed to initialize.");showNotification("Error: Input controller init failed!","error");return} if(config.detection.enabled){ if(!await loadDetectionModel())debug.error("Detection model (MoveNet) failed to load. Detection features disabled.") }else{ debug.log("Detection is disabled in config."),showNotification("AI Detection is disabled.","info"); } startAimbotLoop(); debug.log("Aimbot (MoveNet) initialized and main loop started."); showNotification(`Precision Aimbot V${config.version} (MoveNet) Initialized!`, "info"); }

    (document.readyState==='complete'||document.readyState==='interactive')?setTimeout(initializeAimbot,2500):window.addEventListener('load',()=>setTimeout(initializeAimbot,2500));
})();
